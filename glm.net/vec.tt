<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//	 All your changes to this file will be lost upon re-generation 	 //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
#if DOUBLE_PRECISION
    using scalar = Double;
#else
    using scalar = Single;
#endif

<#
    const string comp = "XYZWVU";
    int maxdim = 11;

    try
    {
        string path = Host.ResolvePath("maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

	for (int dim = 2; dim < maxdim; ++dim)
	{
		string typename = "vec" + dim;
		string[] comps = Enumerable.Range(0, dim).Select(i => "_" + i).ToArray();
#>
	#region <#=typename#>

	/// <summary>
    /// Represents a <#=dim#>-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct <#=typename#>
        : ivec<<#=typename#>>
    {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
		private scalar <#=comps[i]#>;
<#
		}
#>


<#
		if (dim <= comp.Length)
			for (int i = 0; i < dim; ++i)
			{
#>
        /// <summary>
        /// Sets or gets the the vector's <#=comp[i]#>-coefficient
        /// </summary>
        public scalar <#=comp[i]#>
		{
			get => <#=comps[i]#>;
			set => <#=comps[i]#> = value;
		}

<#
			}
#>
        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
<#=string.Join("\n", Enumerable.Range(0, dim).Select(i => $"\t\t\t\t\tcase {i}: return {comps[i]};"))#>
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
				<#=i > 0 ? "else " : ""#>if (index == <#=i#>) <#=comps[i]#> = value;
<#
		}
#>
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => <#=typename#>.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(<#=string.Join(" + ", comps.Select(s => s + " * " + s)) #>);
		
        /// <inheritdoc/>
        public <#=typename#> Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = <#=dim#>;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static <#=typename#> Zero { get; } = new <#=typename#>(0);
<#
		if (dim <= comp.Length)
			for (int i = 0; i < dim; ++i)
			{
				int[] tuple = new int[dim];
				tuple[i] = 1;
#>

        /// <summary>
        /// The unit vector in <#=comp[i]#>-direction
        /// </summary>
        public static <#=typename#> Unit<#=comp[i]#> { get; } = (<#=string.Join(", ", tuple)#>);
<#
			}
#>


		/// <summary>
        /// Creates a new <#=dim#>-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public <#=typename#>(scalar s)
            : this(<#=string.Join(", ", Enumerable.Repeat("s", dim))#>)
        {
        }
		
		/// <summary>
        /// Creates a new <#=dim#>-dimensional vector
        /// </summary>
        public <#=typename#>(<#=string.Join(", ", Enumerable.Range(0, dim).Select(i => "scalar x" + i))#>)
        {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
			<#=comps[i]#> = x<#=i#>;
<#
		}
#>
		}
<#
		for (int i = dim; i < maxdim; ++i)
		{
#>

		/// <summary>
        /// Creates a new <#=dim#>-dimensional vector from the given <#=i#>-dimensional one
        /// </summary>
        /// <param name="v">The <#=i#>-dimensional vector</param>
        public <#=typename#>(vec<#=i#> v)
            : this(<#=string.Join(", ", Enumerable.Range(0, dim).Select(j => $"v[{j}]"))#>)
        {
        }
<#
		}

	    if (dim > 2)
	    {
#>

		/// <summary>
        /// Creates a new <#=dim#>-dimensional vector from the given <#=dim-1#>-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The <#=dim-1#>-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public <#=typename#>(vec<#=dim-1#> v, scalar c)
            : this(<#=string.Join(", ", Enumerable.Range(0, dim - 1).Select(j => $"v[{j}]"))#>, c)
        {
        }
<#
	    }
#>

		/// <summary>
        /// Creates a new <#=dim#>-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public <#=typename#>(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[<#=dim#>]);
			
			
			
        /// <inheritdoc />
        public <#=typename#> Add(<#=typename#> second) => this + second;

        /// <inheritdoc />
        public <#=typename#> Negate(<#=typename#> second) => -this;

        /// <inheritdoc />
        public <#=typename#> Subtract(<#=typename#> second) => this - second;

        /// <inheritdoc />
        public <#=typename#> Multiply(<#=typename#> second) => this * second;

        /// <inheritdoc />
        public <#=typename#> Multiply(scalar factor) => this * factor;

        /// <inheritdoc/>
		public scalar Dot(<#=typename#> other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(<#=typename#> other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public <#=typename#> SwapEntries(int src_idx, int dst_idx)
		{
		    <#=typename#> res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(<#=typename#> other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"(<#=string.Join(", ", comps.Select(s => "{" + s + "}"))#>)";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { <#=string.Join(", ", comps)#> };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is <#=typename#> v<#=string.Concat(comps.Select(s => $" && v.{s}.@is({s})"))#>;

        /// <inheritdoc/>
        public override int GetHashCode() => <#=string.Join(" ^ ", comps.Select(s => s + ".GetHashCode()"))#>;

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(<#=typename#> v1, <#=typename#> v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(<#=typename#> v1, <#=typename#> v2) => v1.IsLinearIndependent(v2);


        public static <#=typename#> operator ~(<#=typename#> v) => v.Normalized;

        public static <#=typename#> operator -(<#=typename#> v) => v * -1;

        public static <#=typename#> operator +(<#=typename#> v1, <#=typename#> v2) => (<#=string.Join(", ", comps.Select(s => $"v1.{s} + v2.{s}"))#>);

        public static <#=typename#> operator +(<#=typename#> v, scalar f) => v + new <#=typename#>(f);

        public static <#=typename#> operator -(<#=typename#> v1, <#=typename#> v2) => v1 + -v2;

        public static <#=typename#> operator -(<#=typename#> v, scalar f) => v + -f;

        public static <#=typename#> operator *(<#=typename#> v, scalar f) => v * new <#=typename#>(f);

        public static <#=typename#> operator *(scalar f, <#=typename#> v) => v * f;

        public static <#=typename#> operator -(scalar f, <#=typename#> v) => -v + f;

        public static <#=typename#> operator *(<#=typename#> v1, <#=typename#> v2) => (<#=string.Join(", ", comps.Select(s => $"v1.{s} * v2.{s}"))#>);

        public static <#=typename#> operator /(<#=typename#> v, scalar f) => v * (1 / f);

        public static scalar operator /(<#=typename#> v1, <#=typename#> v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(<#=typename#> v1, <#=typename#> v2) => v1.Length < v2.Length;

        public static bool operator >(<#=typename#> v1, <#=typename#> v2) => v1.Length > v2.Length;

        public static bool operator <=(<#=typename#> v1, <#=typename#> v2) => v1.Length <= v2.Length;

        public static bool operator >=(<#=typename#> v1, <#=typename#> v2) => v1.Length >= v2.Length;

        public static bool operator ==(<#=typename#> v1, <#=typename#> v2) => v1.Equals(v2);

        public static bool operator !=(<#=typename#> v1, <#=typename#> v2) => !(v1 == v2);

        public static implicit operator (<#=string.Join(", ", Enumerable.Range(0, dim).Select(i => "scalar x" + i))#>) (<#=typename#> v) => (<#=string.Join(", ", comps.Select(s => "v." + s))#>);

        public static implicit operator <#=typename#>((<#=string.Join(", ", Enumerable.Range(0, dim).Select(i => "scalar x" + i))#>) t) => new <#=typename#>(<#=string.Join(", ", Enumerable.Range(0, dim).Select(i => "t.x" + i))#>);

		public static implicit operator poly(<#=typename#> v) => v.ToArray();

		public static explicit operator <#=typename#>(poly p) => new <#=typename#>(p.Coefficients);
    }

	#endregion
<#
	}
#>
}
