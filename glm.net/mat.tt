<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Autogenerated <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
#if DOUBLE_PRECISION
    using scalar = Double;
#else
    using scalar = Single;
#endif

<#
    int maxdim = 11;

    try
    {
        string path = Host.ResolvePath("maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

	IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

	for (int dim = 2; dim < maxdim; ++dim)
	{
		string[] cols = r(0, dim).Select(i => "_c" + i).ToArray();
		string typename = "mat" + dim;
		string vecname = "vec" + dim;
#>
	#region <#=typename#>

	/// <summary>
    /// Represents a square <#=dim#>x<#=dim#> matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct <#=typename#>
        : imat<<#=typename#>, <#=vecname#>>
    {
<#
		foreach (string col in cols)
		{
#>
		private <#=vecname#> <#=col#>;
<#
		}
#>

		
        /// <inheritdoc/>
        public <#=vecname#> this[int column]
        {
			get
            {
                switch (column)
                {
<#=string.Join("\n", r(0, dim).Select(i => $"\t\t\t\t\tcase {i}: return {cols[i]};"))#>
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
				<#=i > 0 ? "else " : ""#>if (column == <#=i#>) <#=cols[i]#> = value;
<#
		}
#>
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				<#=vecname#> v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => <#=typename#>.Dimension;
		
        /// <inheritdoc/>
        public <#=vecname#> MainDiagonal => (<#=string.Join(", ", r(0, dim).Select(i => $"this[{i}, {i}]"))#>);
		
        /// <inheritdoc/>
        public <#=vecname#>[] Columns => new[] { <#=string.Join(", ", cols)#> };
		
        /// <inheritdoc/>
        public <#=vecname#>[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public <#=typename#> Transposed
        {
            get
            {
                <#=typename#> r = <#=typename#>.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public <#=typename#> Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

<#
		if (dim == 2)
		{
#>
                det = 1 / det;

                return new mat2(
                    +this[1, 1] * det,
                    -this[0, 1] * det,
                    -this[1, 0] * det,
                    +this[0, 0] * det
                );
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1];

        /// <inheritdoc/>
        public poly CharacteristicPolynomial => new poly(Determinant, - this[0, 0] - this[1, 1], 1);
<#
		}
		else if (dim == 3)
		{
#>
                det = 1 / det;

                return new mat3(0)
                {
                    [0, 0] = +(this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2]) * det,
                    [1, 0] = -(this[1, 0] * this[2, 2] - this[2, 0] * this[1, 2]) * det,
                    [2, 0] = +(this[1, 0] * this[2, 1] - this[2, 0] * this[1, 1]) * det,
                    [0, 1] = -(this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2]) * det,
                    [1, 1] = +(this[0, 0] * this[2, 2] - this[2, 0] * this[0, 2]) * det,
                    [2, 1] = -(this[0, 0] * this[2, 1] - this[2, 0] * this[0, 1]) * det,
                    [0, 2] = +(this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]) * det,
                    [1, 2] = -(this[0, 0] * this[1, 2] - this[1, 0] * this[0, 2]) * det,
                    [2, 2] = +(this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1]) * det
                };
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => this[0, 0] * (this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2])
								  - this[1, 0] * (this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2])
								  + this[2, 0] * (this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]);

		/*
				 | a b c |					| a-λ  b   c  |
			φ := | d e f |	   CP_φ(λ) = det|  d  e-λ  f  | = (a-λ)[MINOR @ 1,1] - λ(gc + db) - gbf - gce - dbi +dhc
				 | g h i |					|  g   h  i-λ |
		*/
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => new poly(
             this[1, 0] * this[2, 1] * this[0, 2] // -bgf
           - this[0, 2] * this[2, 0] * this[1, 1] // -gce
           - this[1, 0] * this[0, 1] * this[2, 2] // -dbi
           + this[0, 1] * this[1, 2] * this[2, 0], //+dhc
           - this[0, 2] * this[2, 0] // -gc
           - this[0, 1] * this[1, 0] // -db
        ) + ((this[0, 0] - poly.X) * Minor(0, 0).CharacteristicPolynomial);
<#
		}
		else
		{
#>
		        <#=typename#> m = this;
			    <#=typename#> u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => <#=string.Join("\n\t\t\t\t\t\t\t\t\t", r(0, dim).Select(i => $"{((i % 2) == 0 ? '+' : '-')} Minor(0, {i}).Determinant"))#>;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}
<#
		}
#>

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public <#=typename#> OrthonormalBasis
        {
            get
            {
				<#=vecname#>[] vs = new <#=vecname#>[<#=dim#>];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < <#=dim#>; ++c)
			        for (int r = 0; r < <#=dim#>; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < <#=dim#>; ++c)
			        for (int r = c + 1; r < <#=dim#>; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != <#=vecname#>.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = <#=dim#>;
		
	    /// <summary>
        /// The <#=dim#>x<#=dim#> zero matrix
        /// </summary>
        public static <#=typename#> Zero { get; } = new <#=typename#>(0);
		
	    /// <summary>
        /// The <#=dim#>x<#=dim#> identity (unit) matrix
        /// </summary>
        public static <#=typename#> Identity { get; } = new <#=typename#>(1);


        public <#=typename#>(scalar scale)
            : this(<#=string.Join(",\n\t\t\t\t   ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => j == i ? "scale" : "0"))})"))#>)
        {
        }

        public <#=typename#>(IEnumerable<<#=vecname#>> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public <#=typename#>(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"{vecname} v{i}"))#>)
        {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
			<#=cols[i]#> = v<#=i#>;
<#
		}
#>
        }
		


		public <#=vecname#> Solve(<#=vecname#> v)
		{
		    <#=typename#> m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal <#=typename#> GetLinearIndependentForm()
		{
		    <#=typename#> m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (<#=typename#> U, <#=typename#> D) IwasawaDecompose()
        {
            <#=typename#> ONB = OrthonormalBasis;
            <#=typename#> D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(<#=vecname#>[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();
<#
		for (int i = 2; i <= dim - 1; ++i)
		{
#>

        /// <summary>
        /// Returns the upper-left <#=i#>x<#=i#> sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns><#=i#>x<#=i#> sub-matrix</returns>
        public mat<#=i#> ToMatix<#=i#>() => (
<#
			for (int j = 0; j < i; ++j)
			{
#>
			(<#=string.Join(", ", r(0, i).Select(k => $"{cols[j]}[{k}]"))#>)<#=j < i - 1 ? "," : ""#>
<#
			}
#>
		);
<#
		}

		if (dim > 2)
		{
#>

        /// <summary>
        /// Returns the matrix' <#=dim-1#>x<#=dim-1#>-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns><#=dim-1#>x<#=dim-1#>-minor</returns>
        public mat<#=dim-1#> Minor(int column, int row) => new mat<#=dim-1#>(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec<#=dim-1#>(f.Take(row).Concat(f.Skip(row + 1)));
			}));
<#
		}
#>

        /// <inheritdoc/>
		public <#=typename#> AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public <#=typename#> AddColumns(int src_col, int dst_col, scalar factor)
		{
            <#=typename#> res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public <#=typename#> AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public <#=typename#> AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public <#=typename#> SwapColumns(int src_col, int dst_col)
		{
            <#=vecname#>[] cols = Columns;
            <#=vecname#> tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new <#=typename#>(cols);
		}
		
        /// <inheritdoc/>
		public <#=typename#> SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public <#=typename#> MultiplyColumn(int col, scalar factor)
		{
            <#=vecname#>[] cols = Columns;

            cols[col] *= factor;

            return new <#=typename#>(cols);
		}
		
        /// <inheritdoc/>
		public <#=typename#> MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is <#=typename#> mat<#=string.Concat(r(0, dim).Select(i => $" && mat[{i}] == this[{i}]"))#>;

        /// <inheritdoc/>
        public override int GetHashCode() => <#=string.Join(" ^ ", cols.Select(c => c + ".GetHashCode()"))#>;

		/// <summary>
		/// The <#=dim#>x<#=dim#>-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(<#=typename#> m1, <#=typename#> m2) => m1.Equals(m2);

        public static bool operator !=(<#=typename#> m1, <#=typename#> m2) => !(m1 == m2);

        public static <#=typename#> operator +(<#=typename#> m) => m;

        public static <#=typename#> operator -(<#=typename#> m) => m * -1f;

        public static <#=typename#> operator -(scalar f, <#=typename#> m) => new <#=typename#>(f) - m;

        public static <#=typename#> operator -(<#=typename#> m, scalar f) => m + -f;

        public static <#=typename#> operator +(scalar f, <#=typename#> m) => m + f;

        public static <#=typename#> operator +(<#=typename#> m, scalar f) => m + new <#=typename#>(f);

        public static <#=typename#> operator -(<#=typename#> m1, <#=typename#> m2) => m1 + -m2;

        public static <#=typename#> operator +(<#=typename#> m1, <#=typename#> m2) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"m1[{i}] + m2[{i}]"))#>);

        public static <#=vecname#> operator *(<#=typename#> m, <#=vecname#> v) =>
			new <#=vecname#>(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static <#=typename#> operator *(<#=typename#> m1, <#=typename#> m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new <#=typename#>(range.Select(j => new <#=vecname#>(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static <#=typename#> operator *(<#=typename#> m, scalar f) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}] * f"))#>);

        public static <#=typename#> operator /(<#=typename#> m, scalar f) => m * (1 / f);
<#
		string _vecs = string.Join(", ", r(0, dim).Select(i => $"vec{dim} x{i}"));
		string _scals = string.Join(", ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => $"scalar r{j}"))}) c{i}"));
	    string _flats = string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"scalar x{i}{j}")));
#>

        public static implicit operator (<#=_vecs#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        public static implicit operator <#=typename#>((<#=_vecs#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.x{i}"))#>);

        public static explicit operator (<#=_scals#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        public static explicit operator <#=typename#>((<#=_scals#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.c{i}"))#>);

		public static implicit operator (<#=_flats#>) (<#=typename#> m) => (
<#
	    for (int i = 0; i < dim; ++i)
	    {
#>
            <#=string.Join(", ", r(0, dim).Select(j => $"m[{j}, {i}]"))#><#=i < dim - 1 ? "," : ""#>
<#
	    }
#>
		);

		public static implicit operator <#=typename#>((<#=_flats#>) t) => (
<#
	    for (int i = 0; i < dim; ++i)
	    {
#>
            (<#=string.Join(", ", r(0, dim).Select(j => $"t.x{j}{i}"))#>)<#=i < dim - 1 ? "," : ""#>
<#
	    }
#>
		);

        public static explicit operator <#=vecname#>[](<#=typename#> m) => m.Columns;
		
        public static explicit operator scalar[](<#=typename#> m) => m.ToArray();
		
        public static implicit operator <#=typename#>(<#=vecname#>[] arr) => new <#=typename#>(arr);

        public static implicit operator <#=typename#>(scalar[] arr) => new <#=typename#>(arr);
    }

	#endregion
<#
	}
#>
}
