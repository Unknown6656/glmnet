<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Autogenerated <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
<#
	const int maxdim = 10;

	IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

	for (int dim = 2; dim < maxdim; ++dim)
	{
		string[] cols = r(0, dim).Select(i => "_c" + i).ToArray();
		string typename = "mat" + dim;
		string vecname = "vec" + dim;
#>
	#region <#=typename#>

	/// <summary>
    /// Represents a square <#=dim#>x<#=dim#> matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct <#=typename#>
        : imat<<#=typename#>, <#=vecname#>>
    {
<#
		foreach (string col in cols)
		{
#>
		private <#=vecname#> <#=col#>;
<#
		}
#>

		
        /// <inheritdoc/>
        public <#=vecname#> this[int column]
        {
			get
            {
                switch (column)
                {
<#=string.Join("\n", r(0, dim).Select(i => $"\t\t\t\t\tcase {i}: return {cols[i]};"))#>
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
				<#=i > 0 ? "else " : ""#>if (column == <#=i#>) <#=cols[i]#> = value;
<#
		}
#>
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				<#=vecname#> v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => <#=typename#>.Dimension;
		
        /// <inheritdoc/>
        public <#=vecname#>[] Columns => new[] { <#=string.Join(", ", cols)#> };
		
        /// <inheritdoc/>
        public <#=vecname#>[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public <#=typename#> Transposed
        {
            get
            {
                <#=typename#> r = <#=typename#>.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public <#=typename#> Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

<#
		if (dim == 2)
		{
#>
                det = 1 / det;

                return new mat2(
                    +this[1, 1] * det,
                    -this[0, 1] * det,
                    -this[1, 0] * det,
                    +this[0, 0] * det
                );
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1];
<#
		}
		else if (dim == 3)
		{
#>
                det = 1 / det;

                return new mat3(0)
                {
                    [0, 0] = +(this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2]) * det,
                    [1, 0] = -(this[1, 0] * this[2, 2] - this[2, 0] * this[1, 2]) * det,
                    [2, 0] = +(this[1, 0] * this[2, 1] - this[2, 0] * this[1, 1]) * det,
                    [0, 1] = -(this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2]) * det,
                    [1, 1] = +(this[0, 0] * this[2, 2] - this[2, 0] * this[0, 2]) * det,
                    [2, 1] = -(this[0, 0] * this[2, 1] - this[2, 0] * this[0, 1]) * det,
                    [0, 2] = +(this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]) * det,
                    [1, 2] = -(this[0, 0] * this[1, 2] - this[1, 0] * this[0, 2]) * det,
                    [2, 2] = +(this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1]) * det
                };
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => this[0, 0] * (this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2])
								  - this[1, 0] * (this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2])
								  + this[2, 0] * (this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]);
<#
		}
		else
		{
#>
                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => <#=string.Join("\n\t\t\t\t\t\t\t\t\t", r(0, dim).Select(i => $"{((i % 2) == 0 ? '+' : '-')} Minor(0, {i}).Determinant"))#>;
<#
		}
#>

        /// <inheritdoc/>
        public <#=typename#> OrthonormalBasis
        {
            get
            {
				<#=vecname#>[] vs = new <#=vecname#>[<#=dim#>];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = <#=dim#>;
		
	    /// <summary>
        /// The <#=dim#>x<#=dim#> zero matrix
        /// </summary>
        public static <#=typename#> Zero { get; } = new <#=typename#>(0);
		
	    /// <summary>
        /// The <#=dim#>x<#=dim#> identity (unit) matrix
        /// </summary>
        public static <#=typename#> Identity { get; } = new <#=typename#>(1);


        public <#=typename#>(float scale)
            : this(<#=string.Join(",\n\t\t\t\t   ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => j == i ? "scale" : "0"))})"))#>)
        {
        }

        public <#=typename#>(IEnumerable<<#=vecname#>> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public <#=typename#>(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"{vecname} v{i}"))#>)
        {
<#
		for (int i = 0; i < dim; ++i)
		{
#>
			<#=cols[i]#> = v<#=i#>;
<#
		}
#>
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (<#=typename#> U, <#=typename#> D) IwasawaDecompose()
        {
            <#=typename#> ONB = OrthonormalBasis;
            <#=typename#> D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(<#=vecname#>[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();
<#
		for (int i = 2; i <= dim - 1; ++i)
		{
#>

        /// <summary>
        /// Returns the upper-left <#=i#>x<#=i#> sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns><#=i#>x<#=i#> sub-matrix</returns>
        public mat<#=i#> ToMatix<#=i#>() => (
<#
			for (int j = 0; j < i; ++j)
			{
#>
			(<#=string.Join(", ", r(0, i).Select(k => $"{cols[j]}[{k}]"))#>)<#=j < i - 1 ? "," : ""#>
<#
			}
#>
		);
<#
		}

		if (dim > 2)
		{
#>

        /// <summary>
        /// Returns the matrix' <#=dim-1#>x<#=dim-1#>-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns><#=dim-1#>x<#=dim-1#>-minor</returns>
        public mat<#=dim-1#> Minor(int column, int row) => new mat<#=dim-1#>(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec<#=dim-1#>(f.Take(row).Concat(f.Skip(row + 1)));
			}));
<#
		}
#>

        /// <inheritdoc/>
		public <#=typename#> AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public <#=typename#> AddColumns(int src_col, int dst_col, float factor)
		{
            <#=typename#> res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public <#=typename#> AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public <#=typename#> AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public <#=typename#> SwapColumns(int src_col, int dst_col)
		{
            <#=vecname#>[] cols = Columns;
            <#=vecname#> tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new <#=typename#>(cols);
		}
		
        /// <inheritdoc/>
		public <#=typename#> SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is <#=typename#> mat<#=string.Concat(r(0, dim).Select(i => $" && mat[{i}] == this[{i}]"))#>;

        /// <inheritdoc/>
        public override int GetHashCode() => <#=string.Join(" ^ ", cols.Select(c => c + ".GetHashCode()"))#>;

		/// <summary>
		/// The <#=dim#>x<#=dim#>-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(<#=typename#> m1, <#=typename#> m2) => m1.Equals(m2);

        public static bool operator !=(<#=typename#> m1, <#=typename#> m2) => !(m1 == m2);

        public static <#=typename#> operator +(<#=typename#> m) => m;

        public static <#=typename#> operator -(<#=typename#> m) => m * -1f;

        public static <#=typename#> operator -(float f, <#=typename#> m) => new <#=typename#>(f) - m;

        public static <#=typename#> operator -(<#=typename#> m, float f) => m + -f;

        public static <#=typename#> operator +(float f, <#=typename#> m) => m + f;

        public static <#=typename#> operator +(<#=typename#> m, float f) => m + new <#=typename#>(f);

        public static <#=typename#> operator -(<#=typename#> m1, <#=typename#> m2) => m1 + -m2;

        public static <#=typename#> operator +(<#=typename#> m1, <#=typename#> m2) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"m1[{i}] + m2[{i}]"))#>);

        public static <#=vecname#> operator *(<#=typename#> m, <#=vecname#> v) =>
			new <#=vecname#>(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static <#=typename#> operator *(<#=typename#> m1, <#=typename#> m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new <#=typename#>(range.Select(j => new <#=vecname#>(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static <#=typename#> operator *(<#=typename#> m, float f) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}] * f"))#>);

        public static <#=typename#> operator /(<#=typename#> m, float f) => m * (1 / f);
<#
		string _vecs = string.Join(", ", r(0, dim).Select(i => $"vec{dim} x{i}"));
		string _scals = string.Join(", ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => $"float r{j}"))}) c{i}"));
	    string _flats = string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"float x{i}{j}")));
#>

        public static implicit operator (<#=_vecs#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        public static implicit operator <#=typename#>((<#=_vecs#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.x{i}"))#>);

        public static explicit operator (<#=_scals#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        public static explicit operator <#=typename#>((<#=_scals#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.c{i}"))#>);

		public static implicit operator (<#=_flats#>) (<#=typename#> m) => (
<#
	    for (int i = 0; i < dim; ++i)
	    {
#>
            <#=string.Join(", ", r(0, dim).Select(j => $"m[{j}, {i}]"))#><#=i < dim - 1 ? "," : ""#>
<#
	    }
#>
		);

		public static implicit operator <#=typename#>((<#=_flats#>) t) => (
<#
	    for (int i = 0; i < dim; ++i)
	    {
#>
            (<#=string.Join(", ", r(0, dim).Select(j => $"t.x{j}{i}"))#>)<#=i < dim - 1 ? "," : ""#>
<#
	    }
#>
		);

        public static explicit operator <#=vecname#>[](<#=typename#> m) => m.Columns;
		
        public static explicit operator float[](<#=typename#> m) => m.ToArray();
		
        public static implicit operator <#=typename#>(<#=vecname#>[] arr) => new <#=typename#>(arr);

        public static implicit operator <#=typename#>(float[] arr) => new <#=typename#>(arr);
    }

	#endregion
<#
	}
#>
}
