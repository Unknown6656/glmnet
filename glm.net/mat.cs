///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2018-09-19 00:12:13.083100              //
//	 All your changes to this file will be lost upon re-generation 	 //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
#if DOUBLE_PRECISION
    using scalar = Double;
#else
    using scalar = Single;
#endif

	#region mat2

	/// <summary>
    /// Represents a square 2x2 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat2
        : imat<mat2, vec2>
    {
		private vec2 _c0;
		private vec2 _c1;

		
        /// <inheritdoc/>
        public vec2 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec2 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat2.Dimension;
		
        /// <inheritdoc/>
        public vec2 MainDiagonal => (this[0, 0], this[1, 1]);
		
        /// <inheritdoc/>
        public vec2[] Columns => new[] { _c0, _c1 };
		
        /// <inheritdoc/>
        public vec2[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat2 Transposed
        {
            get
            {
                mat2 r = mat2.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat2 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                det = 1 / det;

                return new mat2(
                    +this[1, 1] * det,
                    -this[0, 1] * det,
                    -this[1, 0] * det,
                    +this[0, 0] * det
                );
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1];

        /// <inheritdoc/>
        public poly CharacteristicPolynomial => new poly(Determinant, - this[0, 0] - this[1, 1], 1);

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat2 OrthonormalBasis
        {
            get
            {
				vec2[] vs = new vec2[2];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 2; ++c)
			        for (int r = 0; r < 2; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 2; ++c)
			        for (int r = c + 1; r < 2; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec2.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 2;
		
	    /// <summary>
        /// The 2x2 zero matrix
        /// </summary>
        public static mat2 Zero { get; } = new mat2(0);
		
	    /// <summary>
        /// The 2x2 identity (unit) matrix
        /// </summary>
        public static mat2 Identity { get; } = new mat2(1);


        public mat2(scalar scale)
            : this((scale, 0),
				   (0, scale))
        {
        }

        public mat2(IEnumerable<vec2> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat2(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat2(vec2 v0, vec2 v1)
        {
			_c0 = v0;
			_c1 = v1;
        }
		

        /// <inheritdoc />
        public mat2 Add(mat2 second) => this + second;

        /// <inheritdoc />
        public mat2 Negate(mat2 second) => -this;

        /// <inheritdoc />
        public mat2 Subtract(mat2 second) => this - second;

        /// <inheritdoc />
        public mat2 Multiply(mat2 second) => this * second;

        /// <inheritdoc />
        public mat2 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec2 Solve(vec2 v)
		{
		    mat2 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat2 GetLinearIndependentForm()
		{
		    mat2 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat2 U, mat2 D) IwasawaDecompose()
        {
            mat2 ONB = OrthonormalBasis;
            mat2 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec2[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <inheritdoc/>
		public mat2 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat2 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat2 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat2 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat2 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat2 SwapColumns(int src_col, int dst_col)
		{
            vec2[] cols = Columns;
            vec2 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat2(cols);
		}
		
        /// <inheritdoc/>
		public mat2 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat2 MultiplyColumn(int col, scalar factor)
		{
            vec2[] cols = Columns;

            cols[col] *= factor;

            return new mat2(cols);
		}
		
        /// <inheritdoc/>
		public mat2 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat2 mat && mat[0] == this[0] && mat[1] == this[1];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode();

		/// <summary>
		/// The 2x2-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat2 m1, mat2 m2) => m1.Equals(m2);

        public static bool operator !=(mat2 m1, mat2 m2) => !(m1 == m2);

        public static mat2 operator +(mat2 m) => m;

        public static mat2 operator -(mat2 m) => m * -1f;

        public static mat2 operator -(scalar f, mat2 m) => new mat2(f) - m;

        public static mat2 operator -(mat2 m, scalar f) => m + -f;

        public static mat2 operator +(scalar f, mat2 m) => m + f;

        public static mat2 operator +(mat2 m, scalar f) => m + new mat2(f);

        public static mat2 operator -(mat2 m1, mat2 m2) => m1 + -m2;

        public static mat2 operator +(mat2 m1, mat2 m2) => new mat2(m1[0] + m2[0], m1[1] + m2[1]);

        public static vec2 operator *(mat2 m, vec2 v) =>
			new vec2(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat2 operator *(mat2 m1, mat2 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat2(range.Select(j => new vec2(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat2 operator *(mat2 m, scalar f) => new mat2(m[0] * f, m[1] * f);

        public static mat2 operator /(mat2 m, scalar f) => m * (1 / f);

        public static implicit operator (vec2 x0, vec2 x1) (mat2 m) => (m[0], m[1]);

        public static implicit operator mat2((vec2 x0, vec2 x1) t) => new mat2(t.x0, t.x1);

        public static explicit operator ((scalar r0, scalar r1) c0, (scalar r0, scalar r1) c1) (mat2 m) => (m[0], m[1]);

        public static explicit operator mat2(((scalar r0, scalar r1) c0, (scalar r0, scalar r1) c1) t) => new mat2(t.c0, t.c1);

		public static implicit operator (scalar x00, scalar x01, scalar x10, scalar x11) (mat2 m) => (
            m[0, 0], m[1, 0],
            m[0, 1], m[1, 1]
		);

		public static implicit operator mat2((scalar x00, scalar x01, scalar x10, scalar x11) t) => (
            (t.x00, t.x10),
            (t.x01, t.x11)
		);

        public static explicit operator vec2[](mat2 m) => m.Columns;
		
        public static explicit operator scalar[](mat2 m) => m.ToArray();
		
        public static implicit operator mat2(vec2[] arr) => new mat2(arr);

        public static implicit operator mat2(scalar[] arr) => new mat2(arr);
    }

	#endregion
	#region mat3

	/// <summary>
    /// Represents a square 3x3 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat3
        : imat<mat3, vec3>
    {
		private vec3 _c0;
		private vec3 _c1;
		private vec3 _c2;

		
        /// <inheritdoc/>
        public vec3 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec3 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat3.Dimension;
		
        /// <inheritdoc/>
        public vec3 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2]);
		
        /// <inheritdoc/>
        public vec3[] Columns => new[] { _c0, _c1, _c2 };
		
        /// <inheritdoc/>
        public vec3[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat3 Transposed
        {
            get
            {
                mat3 r = mat3.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat3 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                det = 1 / det;

                return new mat3(0)
                {
                    [0, 0] = +(this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2]) * det,
                    [1, 0] = -(this[1, 0] * this[2, 2] - this[2, 0] * this[1, 2]) * det,
                    [2, 0] = +(this[1, 0] * this[2, 1] - this[2, 0] * this[1, 1]) * det,
                    [0, 1] = -(this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2]) * det,
                    [1, 1] = +(this[0, 0] * this[2, 2] - this[2, 0] * this[0, 2]) * det,
                    [2, 1] = -(this[0, 0] * this[2, 1] - this[2, 0] * this[0, 1]) * det,
                    [0, 2] = +(this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]) * det,
                    [1, 2] = -(this[0, 0] * this[1, 2] - this[1, 0] * this[0, 2]) * det,
                    [2, 2] = +(this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1]) * det
                };
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => this[0, 0] * (this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2])
								  - this[1, 0] * (this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2])
								  + this[2, 0] * (this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]);

		/*
				 | a b c |					| a-λ  b   c  |
			φ := | d e f |	   CP_φ(λ) = det|  d  e-λ  f  | = (a-λ)[MINOR @ 1,1] - λ(gc + db) - gbf - gce - dbi +dhc
				 | g h i |					|  g   h  i-λ |
		*/
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => new poly(
             this[1, 0] * this[2, 1] * this[0, 2] // -bgf
           - this[0, 2] * this[2, 0] * this[1, 1] // -gce
           - this[1, 0] * this[0, 1] * this[2, 2] // -dbi
           + this[0, 1] * this[1, 2] * this[2, 0], //+dhc
           - this[0, 2] * this[2, 0] // -gc
           - this[0, 1] * this[1, 0] // -db
        ) + ((this[0, 0] - poly.X) * Minor(0, 0).CharacteristicPolynomial);

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat3 OrthonormalBasis
        {
            get
            {
				vec3[] vs = new vec3[3];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 3; ++c)
			        for (int r = 0; r < 3; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 3; ++c)
			        for (int r = c + 1; r < 3; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec3.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 3;
		
	    /// <summary>
        /// The 3x3 zero matrix
        /// </summary>
        public static mat3 Zero { get; } = new mat3(0);
		
	    /// <summary>
        /// The 3x3 identity (unit) matrix
        /// </summary>
        public static mat3 Identity { get; } = new mat3(1);


        public mat3(scalar scale)
            : this((scale, 0, 0),
				   (0, scale, 0),
				   (0, 0, scale))
        {
        }

        public mat3(IEnumerable<vec3> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat3(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat3(vec3 v0, vec3 v1, vec3 v2)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
        }
		

        /// <inheritdoc />
        public mat3 Add(mat3 second) => this + second;

        /// <inheritdoc />
        public mat3 Negate(mat3 second) => -this;

        /// <inheritdoc />
        public mat3 Subtract(mat3 second) => this - second;

        /// <inheritdoc />
        public mat3 Multiply(mat3 second) => this * second;

        /// <inheritdoc />
        public mat3 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec3 Solve(vec3 v)
		{
		    mat3 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat3 GetLinearIndependentForm()
		{
		    mat3 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat3 U, mat3 D) IwasawaDecompose()
        {
            mat3 ONB = OrthonormalBasis;
            mat3 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec3[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the matrix' 2x2-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>2x2-minor</returns>
        public mat2 Minor(int column, int row) => new mat2(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec2(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat3 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat3 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat3 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat3 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat3 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat3 SwapColumns(int src_col, int dst_col)
		{
            vec3[] cols = Columns;
            vec3 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat3(cols);
		}
		
        /// <inheritdoc/>
		public mat3 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat3 MultiplyColumn(int col, scalar factor)
		{
            vec3[] cols = Columns;

            cols[col] *= factor;

            return new mat3(cols);
		}
		
        /// <inheritdoc/>
		public mat3 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat3 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode();

		/// <summary>
		/// The 3x3-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat3 m1, mat3 m2) => m1.Equals(m2);

        public static bool operator !=(mat3 m1, mat3 m2) => !(m1 == m2);

        public static mat3 operator +(mat3 m) => m;

        public static mat3 operator -(mat3 m) => m * -1f;

        public static mat3 operator -(scalar f, mat3 m) => new mat3(f) - m;

        public static mat3 operator -(mat3 m, scalar f) => m + -f;

        public static mat3 operator +(scalar f, mat3 m) => m + f;

        public static mat3 operator +(mat3 m, scalar f) => m + new mat3(f);

        public static mat3 operator -(mat3 m1, mat3 m2) => m1 + -m2;

        public static mat3 operator +(mat3 m1, mat3 m2) => new mat3(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2]);

        public static vec3 operator *(mat3 m, vec3 v) =>
			new vec3(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat3 operator *(mat3 m1, mat3 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat3(range.Select(j => new vec3(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat3 operator *(mat3 m, scalar f) => new mat3(m[0] * f, m[1] * f, m[2] * f);

        public static mat3 operator /(mat3 m, scalar f) => m * (1 / f);

        public static implicit operator (vec3 x0, vec3 x1, vec3 x2) (mat3 m) => (m[0], m[1], m[2]);

        public static implicit operator mat3((vec3 x0, vec3 x1, vec3 x2) t) => new mat3(t.x0, t.x1, t.x2);

        public static explicit operator ((scalar r0, scalar r1, scalar r2) c0, (scalar r0, scalar r1, scalar r2) c1, (scalar r0, scalar r1, scalar r2) c2) (mat3 m) => (m[0], m[1], m[2]);

        public static explicit operator mat3(((scalar r0, scalar r1, scalar r2) c0, (scalar r0, scalar r1, scalar r2) c1, (scalar r0, scalar r1, scalar r2) c2) t) => new mat3(t.c0, t.c1, t.c2);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x10, scalar x11, scalar x12, scalar x20, scalar x21, scalar x22) (mat3 m) => (
            m[0, 0], m[1, 0], m[2, 0],
            m[0, 1], m[1, 1], m[2, 1],
            m[0, 2], m[1, 2], m[2, 2]
		);

		public static implicit operator mat3((scalar x00, scalar x01, scalar x02, scalar x10, scalar x11, scalar x12, scalar x20, scalar x21, scalar x22) t) => (
            (t.x00, t.x10, t.x20),
            (t.x01, t.x11, t.x21),
            (t.x02, t.x12, t.x22)
		);

        public static explicit operator vec3[](mat3 m) => m.Columns;
		
        public static explicit operator scalar[](mat3 m) => m.ToArray();
		
        public static implicit operator mat3(vec3[] arr) => new mat3(arr);

        public static implicit operator mat3(scalar[] arr) => new mat3(arr);
    }

	#endregion
	#region mat4

	/// <summary>
    /// Represents a square 4x4 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat4
        : imat<mat4, vec4>
    {
		private vec4 _c0;
		private vec4 _c1;
		private vec4 _c2;
		private vec4 _c3;

		
        /// <inheritdoc/>
        public vec4 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec4 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat4.Dimension;
		
        /// <inheritdoc/>
        public vec4 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3]);
		
        /// <inheritdoc/>
        public vec4[] Columns => new[] { _c0, _c1, _c2, _c3 };
		
        /// <inheritdoc/>
        public vec4[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat4 Transposed
        {
            get
            {
                mat4 r = mat4.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat4 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat4 m = this;
			    mat4 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat4 OrthonormalBasis
        {
            get
            {
				vec4[] vs = new vec4[4];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 4; ++c)
			        for (int r = 0; r < 4; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 4; ++c)
			        for (int r = c + 1; r < 4; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec4.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 4;
		
	    /// <summary>
        /// The 4x4 zero matrix
        /// </summary>
        public static mat4 Zero { get; } = new mat4(0);
		
	    /// <summary>
        /// The 4x4 identity (unit) matrix
        /// </summary>
        public static mat4 Identity { get; } = new mat4(1);


        public mat4(scalar scale)
            : this((scale, 0, 0, 0),
				   (0, scale, 0, 0),
				   (0, 0, scale, 0),
				   (0, 0, 0, scale))
        {
        }

        public mat4(IEnumerable<vec4> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat4(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat4(vec4 v0, vec4 v1, vec4 v2, vec4 v3)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
        }
		

        /// <inheritdoc />
        public mat4 Add(mat4 second) => this + second;

        /// <inheritdoc />
        public mat4 Negate(mat4 second) => -this;

        /// <inheritdoc />
        public mat4 Subtract(mat4 second) => this - second;

        /// <inheritdoc />
        public mat4 Multiply(mat4 second) => this * second;

        /// <inheritdoc />
        public mat4 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec4 Solve(vec4 v)
		{
		    mat4 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat4 GetLinearIndependentForm()
		{
		    mat4 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat4 U, mat4 D) IwasawaDecompose()
        {
            mat4 ONB = OrthonormalBasis;
            mat4 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec4[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the matrix' 3x3-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>3x3-minor</returns>
        public mat3 Minor(int column, int row) => new mat3(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec3(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat4 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat4 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat4 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat4 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat4 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat4 SwapColumns(int src_col, int dst_col)
		{
            vec4[] cols = Columns;
            vec4 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat4(cols);
		}
		
        /// <inheritdoc/>
		public mat4 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat4 MultiplyColumn(int col, scalar factor)
		{
            vec4[] cols = Columns;

            cols[col] *= factor;

            return new mat4(cols);
		}
		
        /// <inheritdoc/>
		public mat4 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat4 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode();

		/// <summary>
		/// The 4x4-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat4 m1, mat4 m2) => m1.Equals(m2);

        public static bool operator !=(mat4 m1, mat4 m2) => !(m1 == m2);

        public static mat4 operator +(mat4 m) => m;

        public static mat4 operator -(mat4 m) => m * -1f;

        public static mat4 operator -(scalar f, mat4 m) => new mat4(f) - m;

        public static mat4 operator -(mat4 m, scalar f) => m + -f;

        public static mat4 operator +(scalar f, mat4 m) => m + f;

        public static mat4 operator +(mat4 m, scalar f) => m + new mat4(f);

        public static mat4 operator -(mat4 m1, mat4 m2) => m1 + -m2;

        public static mat4 operator +(mat4 m1, mat4 m2) => new mat4(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3]);

        public static vec4 operator *(mat4 m, vec4 v) =>
			new vec4(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat4 operator *(mat4 m1, mat4 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat4(range.Select(j => new vec4(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat4 operator *(mat4 m, scalar f) => new mat4(m[0] * f, m[1] * f, m[2] * f, m[3] * f);

        public static mat4 operator /(mat4 m, scalar f) => m * (1 / f);

        public static implicit operator (vec4 x0, vec4 x1, vec4 x2, vec4 x3) (mat4 m) => (m[0], m[1], m[2], m[3]);

        public static implicit operator mat4((vec4 x0, vec4 x1, vec4 x2, vec4 x3) t) => new mat4(t.x0, t.x1, t.x2, t.x3);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3) c0, (scalar r0, scalar r1, scalar r2, scalar r3) c1, (scalar r0, scalar r1, scalar r2, scalar r3) c2, (scalar r0, scalar r1, scalar r2, scalar r3) c3) (mat4 m) => (m[0], m[1], m[2], m[3]);

        public static explicit operator mat4(((scalar r0, scalar r1, scalar r2, scalar r3) c0, (scalar r0, scalar r1, scalar r2, scalar r3) c1, (scalar r0, scalar r1, scalar r2, scalar r3) c2, (scalar r0, scalar r1, scalar r2, scalar r3) c3) t) => new mat4(t.c0, t.c1, t.c2, t.c3);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x10, scalar x11, scalar x12, scalar x13, scalar x20, scalar x21, scalar x22, scalar x23, scalar x30, scalar x31, scalar x32, scalar x33) (mat4 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3]
		);

		public static implicit operator mat4((scalar x00, scalar x01, scalar x02, scalar x03, scalar x10, scalar x11, scalar x12, scalar x13, scalar x20, scalar x21, scalar x22, scalar x23, scalar x30, scalar x31, scalar x32, scalar x33) t) => (
            (t.x00, t.x10, t.x20, t.x30),
            (t.x01, t.x11, t.x21, t.x31),
            (t.x02, t.x12, t.x22, t.x32),
            (t.x03, t.x13, t.x23, t.x33)
		);

        public static explicit operator vec4[](mat4 m) => m.Columns;
		
        public static explicit operator scalar[](mat4 m) => m.ToArray();
		
        public static implicit operator mat4(vec4[] arr) => new mat4(arr);

        public static implicit operator mat4(scalar[] arr) => new mat4(arr);
    }

	#endregion
	#region mat5

	/// <summary>
    /// Represents a square 5x5 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat5
        : imat<mat5, vec5>
    {
		private vec5 _c0;
		private vec5 _c1;
		private vec5 _c2;
		private vec5 _c3;
		private vec5 _c4;

		
        /// <inheritdoc/>
        public vec5 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec5 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat5.Dimension;
		
        /// <inheritdoc/>
        public vec5 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4]);
		
        /// <inheritdoc/>
        public vec5[] Columns => new[] { _c0, _c1, _c2, _c3, _c4 };
		
        /// <inheritdoc/>
        public vec5[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat5 Transposed
        {
            get
            {
                mat5 r = mat5.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat5 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat5 m = this;
			    mat5 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat5 OrthonormalBasis
        {
            get
            {
				vec5[] vs = new vec5[5];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 5; ++c)
			        for (int r = 0; r < 5; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 5; ++c)
			        for (int r = c + 1; r < 5; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec5.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 5;
		
	    /// <summary>
        /// The 5x5 zero matrix
        /// </summary>
        public static mat5 Zero { get; } = new mat5(0);
		
	    /// <summary>
        /// The 5x5 identity (unit) matrix
        /// </summary>
        public static mat5 Identity { get; } = new mat5(1);


        public mat5(scalar scale)
            : this((scale, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0),
				   (0, 0, scale, 0, 0),
				   (0, 0, 0, scale, 0),
				   (0, 0, 0, 0, scale))
        {
        }

        public mat5(IEnumerable<vec5> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat5(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat5(vec5 v0, vec5 v1, vec5 v2, vec5 v3, vec5 v4)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
        }
		

        /// <inheritdoc />
        public mat5 Add(mat5 second) => this + second;

        /// <inheritdoc />
        public mat5 Negate(mat5 second) => -this;

        /// <inheritdoc />
        public mat5 Subtract(mat5 second) => this - second;

        /// <inheritdoc />
        public mat5 Multiply(mat5 second) => this * second;

        /// <inheritdoc />
        public mat5 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec5 Solve(vec5 v)
		{
		    mat5 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat5 GetLinearIndependentForm()
		{
		    mat5 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat5 U, mat5 D) IwasawaDecompose()
        {
            mat5 ONB = OrthonormalBasis;
            mat5 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec5[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the matrix' 4x4-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>4x4-minor</returns>
        public mat4 Minor(int column, int row) => new mat4(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec4(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat5 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat5 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat5 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat5 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat5 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat5 SwapColumns(int src_col, int dst_col)
		{
            vec5[] cols = Columns;
            vec5 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat5(cols);
		}
		
        /// <inheritdoc/>
		public mat5 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat5 MultiplyColumn(int col, scalar factor)
		{
            vec5[] cols = Columns;

            cols[col] *= factor;

            return new mat5(cols);
		}
		
        /// <inheritdoc/>
		public mat5 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat5 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode();

		/// <summary>
		/// The 5x5-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat5 m1, mat5 m2) => m1.Equals(m2);

        public static bool operator !=(mat5 m1, mat5 m2) => !(m1 == m2);

        public static mat5 operator +(mat5 m) => m;

        public static mat5 operator -(mat5 m) => m * -1f;

        public static mat5 operator -(scalar f, mat5 m) => new mat5(f) - m;

        public static mat5 operator -(mat5 m, scalar f) => m + -f;

        public static mat5 operator +(scalar f, mat5 m) => m + f;

        public static mat5 operator +(mat5 m, scalar f) => m + new mat5(f);

        public static mat5 operator -(mat5 m1, mat5 m2) => m1 + -m2;

        public static mat5 operator +(mat5 m1, mat5 m2) => new mat5(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4]);

        public static vec5 operator *(mat5 m, vec5 v) =>
			new vec5(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat5 operator *(mat5 m1, mat5 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat5(range.Select(j => new vec5(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat5 operator *(mat5 m, scalar f) => new mat5(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f);

        public static mat5 operator /(mat5 m, scalar f) => m * (1 / f);

        public static implicit operator (vec5 x0, vec5 x1, vec5 x2, vec5 x3, vec5 x4) (mat5 m) => (m[0], m[1], m[2], m[3], m[4]);

        public static implicit operator mat5((vec5 x0, vec5 x1, vec5 x2, vec5 x3, vec5 x4) t) => new mat5(t.x0, t.x1, t.x2, t.x3, t.x4);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c4) (mat5 m) => (m[0], m[1], m[2], m[3], m[4]);

        public static explicit operator mat5(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4) c4) t) => new mat5(t.c0, t.c1, t.c2, t.c3, t.c4);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44) (mat5 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4]
		);

		public static implicit operator mat5((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40),
            (t.x01, t.x11, t.x21, t.x31, t.x41),
            (t.x02, t.x12, t.x22, t.x32, t.x42),
            (t.x03, t.x13, t.x23, t.x33, t.x43),
            (t.x04, t.x14, t.x24, t.x34, t.x44)
		);

        public static explicit operator vec5[](mat5 m) => m.Columns;
		
        public static explicit operator scalar[](mat5 m) => m.ToArray();
		
        public static implicit operator mat5(vec5[] arr) => new mat5(arr);

        public static implicit operator mat5(scalar[] arr) => new mat5(arr);
    }

	#endregion
	#region mat6

	/// <summary>
    /// Represents a square 6x6 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat6
        : imat<mat6, vec6>
    {
		private vec6 _c0;
		private vec6 _c1;
		private vec6 _c2;
		private vec6 _c3;
		private vec6 _c4;
		private vec6 _c5;

		
        /// <inheritdoc/>
        public vec6 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec6 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat6.Dimension;
		
        /// <inheritdoc/>
        public vec6 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4], this[5, 5]);
		
        /// <inheritdoc/>
        public vec6[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5 };
		
        /// <inheritdoc/>
        public vec6[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat6 Transposed
        {
            get
            {
                mat6 r = mat6.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat6 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat6 m = this;
			    mat6 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat6 OrthonormalBasis
        {
            get
            {
				vec6[] vs = new vec6[6];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 6; ++c)
			        for (int r = 0; r < 6; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 6; ++c)
			        for (int r = c + 1; r < 6; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec6.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 6;
		
	    /// <summary>
        /// The 6x6 zero matrix
        /// </summary>
        public static mat6 Zero { get; } = new mat6(0);
		
	    /// <summary>
        /// The 6x6 identity (unit) matrix
        /// </summary>
        public static mat6 Identity { get; } = new mat6(1);


        public mat6(scalar scale)
            : this((scale, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, scale))
        {
        }

        public mat6(IEnumerable<vec6> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat6(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat6(vec6 v0, vec6 v1, vec6 v2, vec6 v3, vec6 v4, vec6 v5)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
        }
		

        /// <inheritdoc />
        public mat6 Add(mat6 second) => this + second;

        /// <inheritdoc />
        public mat6 Negate(mat6 second) => -this;

        /// <inheritdoc />
        public mat6 Subtract(mat6 second) => this - second;

        /// <inheritdoc />
        public mat6 Multiply(mat6 second) => this * second;

        /// <inheritdoc />
        public mat6 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec6 Solve(vec6 v)
		{
		    mat6 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat6 GetLinearIndependentForm()
		{
		    mat6 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat6 U, mat6 D) IwasawaDecompose()
        {
            mat6 ONB = OrthonormalBasis;
            mat6 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec6[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the matrix' 5x5-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>5x5-minor</returns>
        public mat5 Minor(int column, int row) => new mat5(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec5(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat6 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat6 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat6 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat6 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat6 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat6 SwapColumns(int src_col, int dst_col)
		{
            vec6[] cols = Columns;
            vec6 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat6(cols);
		}
		
        /// <inheritdoc/>
		public mat6 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat6 MultiplyColumn(int col, scalar factor)
		{
            vec6[] cols = Columns;

            cols[col] *= factor;

            return new mat6(cols);
		}
		
        /// <inheritdoc/>
		public mat6 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat6 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode();

		/// <summary>
		/// The 6x6-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat6 m1, mat6 m2) => m1.Equals(m2);

        public static bool operator !=(mat6 m1, mat6 m2) => !(m1 == m2);

        public static mat6 operator +(mat6 m) => m;

        public static mat6 operator -(mat6 m) => m * -1f;

        public static mat6 operator -(scalar f, mat6 m) => new mat6(f) - m;

        public static mat6 operator -(mat6 m, scalar f) => m + -f;

        public static mat6 operator +(scalar f, mat6 m) => m + f;

        public static mat6 operator +(mat6 m, scalar f) => m + new mat6(f);

        public static mat6 operator -(mat6 m1, mat6 m2) => m1 + -m2;

        public static mat6 operator +(mat6 m1, mat6 m2) => new mat6(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5]);

        public static vec6 operator *(mat6 m, vec6 v) =>
			new vec6(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat6 operator *(mat6 m1, mat6 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat6(range.Select(j => new vec6(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat6 operator *(mat6 m, scalar f) => new mat6(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f);

        public static mat6 operator /(mat6 m, scalar f) => m * (1 / f);

        public static implicit operator (vec6 x0, vec6 x1, vec6 x2, vec6 x3, vec6 x4, vec6 x5) (mat6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

        public static implicit operator mat6((vec6 x0, vec6 x1, vec6 x2, vec6 x3, vec6 x4, vec6 x5) t) => new mat6(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c5) (mat6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

        public static explicit operator mat6(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5) c5) t) => new mat6(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55) (mat6 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5]
		);

		public static implicit operator mat6((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55)
		);

        public static explicit operator vec6[](mat6 m) => m.Columns;
		
        public static explicit operator scalar[](mat6 m) => m.ToArray();
		
        public static implicit operator mat6(vec6[] arr) => new mat6(arr);

        public static implicit operator mat6(scalar[] arr) => new mat6(arr);
    }

	#endregion
	#region mat7

	/// <summary>
    /// Represents a square 7x7 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat7
        : imat<mat7, vec7>
    {
		private vec7 _c0;
		private vec7 _c1;
		private vec7 _c2;
		private vec7 _c3;
		private vec7 _c4;
		private vec7 _c5;
		private vec7 _c6;

		
        /// <inheritdoc/>
        public vec7 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec7 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat7.Dimension;
		
        /// <inheritdoc/>
        public vec7 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4], this[5, 5], this[6, 6]);
		
        /// <inheritdoc/>
        public vec7[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6 };
		
        /// <inheritdoc/>
        public vec7[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat7 Transposed
        {
            get
            {
                mat7 r = mat7.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat7 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat7 m = this;
			    mat7 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat7 OrthonormalBasis
        {
            get
            {
				vec7[] vs = new vec7[7];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 7; ++c)
			        for (int r = 0; r < 7; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 7; ++c)
			        for (int r = c + 1; r < 7; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec7.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 7;
		
	    /// <summary>
        /// The 7x7 zero matrix
        /// </summary>
        public static mat7 Zero { get; } = new mat7(0);
		
	    /// <summary>
        /// The 7x7 identity (unit) matrix
        /// </summary>
        public static mat7 Identity { get; } = new mat7(1);


        public mat7(scalar scale)
            : this((scale, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat7(IEnumerable<vec7> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat7(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat7(vec7 v0, vec7 v1, vec7 v2, vec7 v3, vec7 v4, vec7 v5, vec7 v6)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
        }
		

        /// <inheritdoc />
        public mat7 Add(mat7 second) => this + second;

        /// <inheritdoc />
        public mat7 Negate(mat7 second) => -this;

        /// <inheritdoc />
        public mat7 Subtract(mat7 second) => this - second;

        /// <inheritdoc />
        public mat7 Multiply(mat7 second) => this * second;

        /// <inheritdoc />
        public mat7 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec7 Solve(vec7 v)
		{
		    mat7 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat7 GetLinearIndependentForm()
		{
		    mat7 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat7 U, mat7 D) IwasawaDecompose()
        {
            mat7 ONB = OrthonormalBasis;
            mat7 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec7[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the matrix' 6x6-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>6x6-minor</returns>
        public mat6 Minor(int column, int row) => new mat6(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec6(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat7 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat7 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat7 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat7 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat7 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat7 SwapColumns(int src_col, int dst_col)
		{
            vec7[] cols = Columns;
            vec7 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat7(cols);
		}
		
        /// <inheritdoc/>
		public mat7 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat7 MultiplyColumn(int col, scalar factor)
		{
            vec7[] cols = Columns;

            cols[col] *= factor;

            return new mat7(cols);
		}
		
        /// <inheritdoc/>
		public mat7 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat7 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode();

		/// <summary>
		/// The 7x7-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat7 m1, mat7 m2) => m1.Equals(m2);

        public static bool operator !=(mat7 m1, mat7 m2) => !(m1 == m2);

        public static mat7 operator +(mat7 m) => m;

        public static mat7 operator -(mat7 m) => m * -1f;

        public static mat7 operator -(scalar f, mat7 m) => new mat7(f) - m;

        public static mat7 operator -(mat7 m, scalar f) => m + -f;

        public static mat7 operator +(scalar f, mat7 m) => m + f;

        public static mat7 operator +(mat7 m, scalar f) => m + new mat7(f);

        public static mat7 operator -(mat7 m1, mat7 m2) => m1 + -m2;

        public static mat7 operator +(mat7 m1, mat7 m2) => new mat7(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6]);

        public static vec7 operator *(mat7 m, vec7 v) =>
			new vec7(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat7 operator *(mat7 m1, mat7 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat7(range.Select(j => new vec7(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat7 operator *(mat7 m, scalar f) => new mat7(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f);

        public static mat7 operator /(mat7 m, scalar f) => m * (1 / f);

        public static implicit operator (vec7 x0, vec7 x1, vec7 x2, vec7 x3, vec7 x4, vec7 x5, vec7 x6) (mat7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

        public static implicit operator mat7((vec7 x0, vec7 x1, vec7 x2, vec7 x3, vec7 x4, vec7 x5, vec7 x6) t) => new mat7(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c6) (mat7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

        public static explicit operator mat7(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6) c6) t) => new mat7(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66) (mat7 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6]
		);

		public static implicit operator mat7((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66)
		);

        public static explicit operator vec7[](mat7 m) => m.Columns;
		
        public static explicit operator scalar[](mat7 m) => m.ToArray();
		
        public static implicit operator mat7(vec7[] arr) => new mat7(arr);

        public static implicit operator mat7(scalar[] arr) => new mat7(arr);
    }

	#endregion
	#region mat8

	/// <summary>
    /// Represents a square 8x8 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat8
        : imat<mat8, vec8>
    {
		private vec8 _c0;
		private vec8 _c1;
		private vec8 _c2;
		private vec8 _c3;
		private vec8 _c4;
		private vec8 _c5;
		private vec8 _c6;
		private vec8 _c7;

		
        /// <inheritdoc/>
        public vec8 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
					case 7: return _c7;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
				else if (column == 7) _c7 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec8 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat8.Dimension;
		
        /// <inheritdoc/>
        public vec8 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4], this[5, 5], this[6, 6], this[7, 7]);
		
        /// <inheritdoc/>
        public vec8[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7 };
		
        /// <inheritdoc/>
        public vec8[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat8 Transposed
        {
            get
            {
                mat8 r = mat8.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat8 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat8 m = this;
			    mat8 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant
									- Minor(0, 7).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat8 OrthonormalBasis
        {
            get
            {
				vec8[] vs = new vec8[8];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 8; ++c)
			        for (int r = 0; r < 8; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 8; ++c)
			        for (int r = c + 1; r < 8; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec8.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 8;
		
	    /// <summary>
        /// The 8x8 zero matrix
        /// </summary>
        public static mat8 Zero { get; } = new mat8(0);
		
	    /// <summary>
        /// The 8x8 identity (unit) matrix
        /// </summary>
        public static mat8 Identity { get; } = new mat8(1);


        public mat8(scalar scale)
            : this((scale, 0, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat8(IEnumerable<vec8> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat8(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat8(vec8 v0, vec8 v1, vec8 v2, vec8 v3, vec8 v4, vec8 v5, vec8 v6, vec8 v7)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
			_c7 = v7;
        }
		

        /// <inheritdoc />
        public mat8 Add(mat8 second) => this + second;

        /// <inheritdoc />
        public mat8 Negate(mat8 second) => -this;

        /// <inheritdoc />
        public mat8 Subtract(mat8 second) => this - second;

        /// <inheritdoc />
        public mat8 Multiply(mat8 second) => this * second;

        /// <inheritdoc />
        public mat8 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec8 Solve(vec8 v)
		{
		    mat8 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat8 GetLinearIndependentForm()
		{
		    mat8 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat8 U, mat8 D) IwasawaDecompose()
        {
            mat8 ONB = OrthonormalBasis;
            mat8 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec8[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>7x7 sub-matrix</returns>
        public mat7 ToMatix7() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6])
		);

        /// <summary>
        /// Returns the matrix' 7x7-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>7x7-minor</returns>
        public mat7 Minor(int column, int row) => new mat7(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec7(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat8 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat8 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat8 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat8 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat8 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat8 SwapColumns(int src_col, int dst_col)
		{
            vec8[] cols = Columns;
            vec8 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat8(cols);
		}
		
        /// <inheritdoc/>
		public mat8 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat8 MultiplyColumn(int col, scalar factor)
		{
            vec8[] cols = Columns;

            cols[col] *= factor;

            return new mat8(cols);
		}
		
        /// <inheritdoc/>
		public mat8 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat8 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6] && mat[7] == this[7];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode() ^ _c7.GetHashCode();

		/// <summary>
		/// The 8x8-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat8 m1, mat8 m2) => m1.Equals(m2);

        public static bool operator !=(mat8 m1, mat8 m2) => !(m1 == m2);

        public static mat8 operator +(mat8 m) => m;

        public static mat8 operator -(mat8 m) => m * -1f;

        public static mat8 operator -(scalar f, mat8 m) => new mat8(f) - m;

        public static mat8 operator -(mat8 m, scalar f) => m + -f;

        public static mat8 operator +(scalar f, mat8 m) => m + f;

        public static mat8 operator +(mat8 m, scalar f) => m + new mat8(f);

        public static mat8 operator -(mat8 m1, mat8 m2) => m1 + -m2;

        public static mat8 operator +(mat8 m1, mat8 m2) => new mat8(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7]);

        public static vec8 operator *(mat8 m, vec8 v) =>
			new vec8(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat8 operator *(mat8 m1, mat8 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat8(range.Select(j => new vec8(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat8 operator *(mat8 m, scalar f) => new mat8(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f, m[7] * f);

        public static mat8 operator /(mat8 m, scalar f) => m * (1 / f);

        public static implicit operator (vec8 x0, vec8 x1, vec8 x2, vec8 x3, vec8 x4, vec8 x5, vec8 x6, vec8 x7) (mat8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

        public static implicit operator mat8((vec8 x0, vec8 x1, vec8 x2, vec8 x3, vec8 x4, vec8 x5, vec8 x6, vec8 x7) t) => new mat8(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c7) (mat8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

        public static explicit operator mat8(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7) c7) t) => new mat8(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77) (mat8 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0], m[7, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1], m[7, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2], m[7, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3], m[7, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4], m[7, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5], m[7, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6], m[7, 6],
            m[0, 7], m[1, 7], m[2, 7], m[3, 7], m[4, 7], m[5, 7], m[6, 7], m[7, 7]
		);

		public static implicit operator mat8((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60, t.x70),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61, t.x71),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62, t.x72),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63, t.x73),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64, t.x74),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65, t.x75),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66, t.x76),
            (t.x07, t.x17, t.x27, t.x37, t.x47, t.x57, t.x67, t.x77)
		);

        public static explicit operator vec8[](mat8 m) => m.Columns;
		
        public static explicit operator scalar[](mat8 m) => m.ToArray();
		
        public static implicit operator mat8(vec8[] arr) => new mat8(arr);

        public static implicit operator mat8(scalar[] arr) => new mat8(arr);
    }

	#endregion
	#region mat9

	/// <summary>
    /// Represents a square 9x9 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat9
        : imat<mat9, vec9>
    {
		private vec9 _c0;
		private vec9 _c1;
		private vec9 _c2;
		private vec9 _c3;
		private vec9 _c4;
		private vec9 _c5;
		private vec9 _c6;
		private vec9 _c7;
		private vec9 _c8;

		
        /// <inheritdoc/>
        public vec9 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
					case 7: return _c7;
					case 8: return _c8;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
				else if (column == 7) _c7 = value;
				else if (column == 8) _c8 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec9 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat9.Dimension;
		
        /// <inheritdoc/>
        public vec9 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4], this[5, 5], this[6, 6], this[7, 7], this[8, 8]);
		
        /// <inheritdoc/>
        public vec9[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8 };
		
        /// <inheritdoc/>
        public vec9[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat9 Transposed
        {
            get
            {
                mat9 r = mat9.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat9 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat9 m = this;
			    mat9 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant
									- Minor(0, 7).Determinant
									+ Minor(0, 8).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat9 OrthonormalBasis
        {
            get
            {
				vec9[] vs = new vec9[9];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 9; ++c)
			        for (int r = 0; r < 9; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 9; ++c)
			        for (int r = c + 1; r < 9; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec9.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 9;
		
	    /// <summary>
        /// The 9x9 zero matrix
        /// </summary>
        public static mat9 Zero { get; } = new mat9(0);
		
	    /// <summary>
        /// The 9x9 identity (unit) matrix
        /// </summary>
        public static mat9 Identity { get; } = new mat9(1);


        public mat9(scalar scale)
            : this((scale, 0, 0, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat9(IEnumerable<vec9> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat9(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat9(vec9 v0, vec9 v1, vec9 v2, vec9 v3, vec9 v4, vec9 v5, vec9 v6, vec9 v7, vec9 v8)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
			_c7 = v7;
			_c8 = v8;
        }
		

        /// <inheritdoc />
        public mat9 Add(mat9 second) => this + second;

        /// <inheritdoc />
        public mat9 Negate(mat9 second) => -this;

        /// <inheritdoc />
        public mat9 Subtract(mat9 second) => this - second;

        /// <inheritdoc />
        public mat9 Multiply(mat9 second) => this * second;

        /// <inheritdoc />
        public mat9 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec9 Solve(vec9 v)
		{
		    mat9 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat9 GetLinearIndependentForm()
		{
		    mat9 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat9 U, mat9 D) IwasawaDecompose()
        {
            mat9 ONB = OrthonormalBasis;
            mat9 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec9[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>7x7 sub-matrix</returns>
        public mat7 ToMatix7() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6])
		);

        /// <summary>
        /// Returns the upper-left 8x8 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>8x8 sub-matrix</returns>
        public mat8 ToMatix8() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7]),
			(_c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7])
		);

        /// <summary>
        /// Returns the matrix' 8x8-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>8x8-minor</returns>
        public mat8 Minor(int column, int row) => new mat8(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec8(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat9 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat9 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat9 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat9 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat9 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat9 SwapColumns(int src_col, int dst_col)
		{
            vec9[] cols = Columns;
            vec9 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat9(cols);
		}
		
        /// <inheritdoc/>
		public mat9 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat9 MultiplyColumn(int col, scalar factor)
		{
            vec9[] cols = Columns;

            cols[col] *= factor;

            return new mat9(cols);
		}
		
        /// <inheritdoc/>
		public mat9 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat9 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6] && mat[7] == this[7] && mat[8] == this[8];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode() ^ _c7.GetHashCode() ^ _c8.GetHashCode();

		/// <summary>
		/// The 9x9-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat9 m1, mat9 m2) => m1.Equals(m2);

        public static bool operator !=(mat9 m1, mat9 m2) => !(m1 == m2);

        public static mat9 operator +(mat9 m) => m;

        public static mat9 operator -(mat9 m) => m * -1f;

        public static mat9 operator -(scalar f, mat9 m) => new mat9(f) - m;

        public static mat9 operator -(mat9 m, scalar f) => m + -f;

        public static mat9 operator +(scalar f, mat9 m) => m + f;

        public static mat9 operator +(mat9 m, scalar f) => m + new mat9(f);

        public static mat9 operator -(mat9 m1, mat9 m2) => m1 + -m2;

        public static mat9 operator +(mat9 m1, mat9 m2) => new mat9(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7], m1[8] + m2[8]);

        public static vec9 operator *(mat9 m, vec9 v) =>
			new vec9(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat9 operator *(mat9 m1, mat9 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat9(range.Select(j => new vec9(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat9 operator *(mat9 m, scalar f) => new mat9(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f, m[7] * f, m[8] * f);

        public static mat9 operator /(mat9 m, scalar f) => m * (1 / f);

        public static implicit operator (vec9 x0, vec9 x1, vec9 x2, vec9 x3, vec9 x4, vec9 x5, vec9 x6, vec9 x7, vec9 x8) (mat9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

        public static implicit operator mat9((vec9 x0, vec9 x1, vec9 x2, vec9 x3, vec9 x4, vec9 x5, vec9 x6, vec9 x7, vec9 x8) t) => new mat9(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c7, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c8) (mat9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

        public static explicit operator mat9(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c7, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8) c8) t) => new mat9(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7, t.c8);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x08, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x18, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x28, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x38, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x48, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x58, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x68, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77, scalar x78, scalar x80, scalar x81, scalar x82, scalar x83, scalar x84, scalar x85, scalar x86, scalar x87, scalar x88) (mat9 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0], m[7, 0], m[8, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1], m[7, 1], m[8, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2], m[7, 2], m[8, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3], m[7, 3], m[8, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4], m[7, 4], m[8, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5], m[7, 5], m[8, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6], m[7, 6], m[8, 6],
            m[0, 7], m[1, 7], m[2, 7], m[3, 7], m[4, 7], m[5, 7], m[6, 7], m[7, 7], m[8, 7],
            m[0, 8], m[1, 8], m[2, 8], m[3, 8], m[4, 8], m[5, 8], m[6, 8], m[7, 8], m[8, 8]
		);

		public static implicit operator mat9((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x08, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x18, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x28, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x38, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x48, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x58, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x68, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77, scalar x78, scalar x80, scalar x81, scalar x82, scalar x83, scalar x84, scalar x85, scalar x86, scalar x87, scalar x88) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60, t.x70, t.x80),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61, t.x71, t.x81),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62, t.x72, t.x82),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63, t.x73, t.x83),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64, t.x74, t.x84),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65, t.x75, t.x85),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66, t.x76, t.x86),
            (t.x07, t.x17, t.x27, t.x37, t.x47, t.x57, t.x67, t.x77, t.x87),
            (t.x08, t.x18, t.x28, t.x38, t.x48, t.x58, t.x68, t.x78, t.x88)
		);

        public static explicit operator vec9[](mat9 m) => m.Columns;
		
        public static explicit operator scalar[](mat9 m) => m.ToArray();
		
        public static implicit operator mat9(vec9[] arr) => new mat9(arr);

        public static implicit operator mat9(scalar[] arr) => new mat9(arr);
    }

	#endregion
	#region mat10

	/// <summary>
    /// Represents a square 10x10 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat10
        : imat<mat10, vec10>
    {
		private vec10 _c0;
		private vec10 _c1;
		private vec10 _c2;
		private vec10 _c3;
		private vec10 _c4;
		private vec10 _c5;
		private vec10 _c6;
		private vec10 _c7;
		private vec10 _c8;
		private vec10 _c9;

		
        /// <inheritdoc/>
        public vec10 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
					case 7: return _c7;
					case 8: return _c8;
					case 9: return _c9;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
				else if (column == 7) _c7 = value;
				else if (column == 8) _c8 = value;
				else if (column == 9) _c9 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public scalar this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec10 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= scalar.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat10.Dimension;
		
        /// <inheritdoc/>
        public vec10 MainDiagonal => (this[0, 0], this[1, 1], this[2, 2], this[3, 3], this[4, 4], this[5, 5], this[6, 6], this[7, 7], this[8, 8], this[9, 9]);
		
        /// <inheritdoc/>
        public vec10[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9 };
		
        /// <inheritdoc/>
        public vec10[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat10 Transposed
        {
            get
            {
                mat10 r = mat10.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat10 Inverse
        {
            get
            {
			    scalar det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

		        mat10 m = this;
			    mat10 u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    scalar top = 1 / m[i, i];

                    if (scalar.IsInfinity(top))
                        continue;
					    
                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top);
                    m[i, i] = 1;

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].is_zero())
                        for (int row = 0; row < i; ++row)
                        {
                            scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

			    return u;
			}
		}
		
        /// <inheritdoc/>
        public scalar Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant
									- Minor(0, 7).Determinant
									+ Minor(0, 8).Determinant
									- Minor(0, 9).Determinant;

        /// <inheritdoc/>
        public poly CharacteristicPolynomial
		{
		    get
			{
			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    ; // CP is linear product of the main diagonal and -λ

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public scalar[] Eigenvalues
		{
		    get
			{
				// TODO : maybe extra cases fro 2x2 or 3x3?

			    if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
				    return MainDiagonal.ToArray().Distinct().ToArray();

			    throw new NotImplementedException();
			}
		}

        /// <inheritdoc/>
        public mat10 OrthonormalBasis
        {
            get
            {
				vec10[] vs = new vec10[10];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[i].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }

        /// <inheritdoc/>
		public bool IsZero => this == Zero;

        /// <inheritdoc/>
		public bool IsIdentity => this == Identity;
        
		/// <inheritdoc/>
		public bool IsDiagonal
		{
		    get
			{
				for (int c = 0; c < 10; ++c)
			        for (int r = 0; r < 10; ++r)
					    if ((r != c) && !this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsUpperTriangular
		{
		    get
			{
				for (int c = 0; c < 10; ++c)
			        for (int r = c + 1; r < 10; ++r)
					    if (!this[c, r].is_zero())
						    return false;

				return true;
			}
		}
        
		/// <inheritdoc/>
		public bool IsLowerTriangular => Transposed.IsUpperTriangular;
		
        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != vec10.Zero);


        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 10;
		
	    /// <summary>
        /// The 10x10 zero matrix
        /// </summary>
        public static mat10 Zero { get; } = new mat10(0);
		
	    /// <summary>
        /// The 10x10 identity (unit) matrix
        /// </summary>
        public static mat10 Identity { get; } = new mat10(1);


        public mat10(scalar scale)
            : this((scale, 0, 0, 0, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0, 0, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, 0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat10(IEnumerable<vec10> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat10(params scalar[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat10(vec10 v0, vec10 v1, vec10 v2, vec10 v3, vec10 v4, vec10 v5, vec10 v6, vec10 v7, vec10 v8, vec10 v9)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
			_c7 = v7;
			_c8 = v8;
			_c9 = v9;
        }
		

        /// <inheritdoc />
        public mat10 Add(mat10 second) => this + second;

        /// <inheritdoc />
        public mat10 Negate(mat10 second) => -this;

        /// <inheritdoc />
        public mat10 Subtract(mat10 second) => this - second;

        /// <inheritdoc />
        public mat10 Multiply(mat10 second) => this * second;

        /// <inheritdoc />
        public mat10 Multiply(scalar factor) => this * factor;

        /// <inheritdoc />
		public vec10 Solve(vec10 v)
		{
		    mat10 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                v[i] *= top;
                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v[j] -= v[i] * f;
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].is_zero())
                    for (int row = 0; row < i; ++row)
                    {
                        scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v[row] -= v[i] * f;
                    }

			return v;
		}
		
		internal mat10 GetLinearIndependentForm()
		{
		    mat10 m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Math.Abs(m[i, j]) > Math.Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                scalar top = 1 / m[i, i];

                if (scalar.IsInfinity(top))
                    continue;

                m = m.MultiplyRow(i, top);
                m[i, i] = 1;

                for (int j = i + 1; j < Dimension; ++j)
                {
                    scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                }
            }

			return m;
		}


		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            scalar k21 = U[0, 1] / U[0, 0];
            scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat10 U, mat10 D) IwasawaDecompose()
        {
            mat10 ONB = OrthonormalBasis;
            mat10 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(scalar[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec10[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>7x7 sub-matrix</returns>
        public mat7 ToMatix7() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6])
		);

        /// <summary>
        /// Returns the upper-left 8x8 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>8x8 sub-matrix</returns>
        public mat8 ToMatix8() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7]),
			(_c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7])
		);

        /// <summary>
        /// Returns the upper-left 9x9 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>9x9 sub-matrix</returns>
        public mat9 ToMatix9() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7], _c0[8]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7], _c1[8]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7], _c2[8]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7], _c3[8]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7], _c4[8]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7], _c5[8]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7], _c6[8]),
			(_c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7], _c7[8]),
			(_c8[0], _c8[1], _c8[2], _c8[3], _c8[4], _c8[5], _c8[6], _c8[7], _c8[8])
		);

        /// <summary>
        /// Returns the matrix' 9x9-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>9x9-minor</returns>
        public mat9 Minor(int column, int row) => new mat9(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				scalar[] f = v.ToArray();

				return new vec9(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat10 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat10 AddColumns(int src_col, int dst_col, scalar factor)
		{
            mat10 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat10 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat10 AddRows(int src_row, int dst_row, scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat10 SwapColumns(int src_col, int dst_col)
		{
            vec10[] cols = Columns;
            vec10 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat10(cols);
		}
		
        /// <inheritdoc/>
		public mat10 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
		public mat10 MultiplyColumn(int col, scalar factor)
		{
            vec10[] cols = Columns;

            cols[col] *= factor;

            return new mat10(cols);
		}
		
        /// <inheritdoc/>
		public mat10 MultiplyRow(int row, scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;




        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat10 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6] && mat[7] == this[7] && mat[8] == this[8] && mat[9] == this[9];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode() ^ _c7.GetHashCode() ^ _c8.GetHashCode() ^ _c9.GetHashCode();

		/// <summary>
		/// The 10x10-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));


        public static bool operator ==(mat10 m1, mat10 m2) => m1.Equals(m2);

        public static bool operator !=(mat10 m1, mat10 m2) => !(m1 == m2);

        public static mat10 operator +(mat10 m) => m;

        public static mat10 operator -(mat10 m) => m * -1f;

        public static mat10 operator -(scalar f, mat10 m) => new mat10(f) - m;

        public static mat10 operator -(mat10 m, scalar f) => m + -f;

        public static mat10 operator +(scalar f, mat10 m) => m + f;

        public static mat10 operator +(mat10 m, scalar f) => m + new mat10(f);

        public static mat10 operator -(mat10 m1, mat10 m2) => m1 + -m2;

        public static mat10 operator +(mat10 m1, mat10 m2) => new mat10(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7], m1[8] + m2[8], m1[9] + m2[9]);

        public static vec10 operator *(mat10 m, vec10 v) =>
			new vec10(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat10 operator *(mat10 m1, mat10 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat10(range.Select(j => new vec10(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat10 operator *(mat10 m, scalar f) => new mat10(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f, m[7] * f, m[8] * f, m[9] * f);

        public static mat10 operator /(mat10 m, scalar f) => m * (1 / f);

        public static implicit operator (vec10 x0, vec10 x1, vec10 x2, vec10 x3, vec10 x4, vec10 x5, vec10 x6, vec10 x7, vec10 x8, vec10 x9) (mat10 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9]);

        public static implicit operator mat10((vec10 x0, vec10 x1, vec10 x2, vec10 x3, vec10 x4, vec10 x5, vec10 x6, vec10 x7, vec10 x8, vec10 x9) t) => new mat10(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8, t.x9);

        public static explicit operator ((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c7, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c8, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c9) (mat10 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9]);

        public static explicit operator mat10(((scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c0, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c1, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c2, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c3, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c4, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c5, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c6, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c7, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c8, (scalar r0, scalar r1, scalar r2, scalar r3, scalar r4, scalar r5, scalar r6, scalar r7, scalar r8, scalar r9) c9) t) => new mat10(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7, t.c8, t.c9);

		public static implicit operator (scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x08, scalar x09, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x18, scalar x19, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x28, scalar x29, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x38, scalar x39, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x48, scalar x49, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x58, scalar x59, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x68, scalar x69, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77, scalar x78, scalar x79, scalar x80, scalar x81, scalar x82, scalar x83, scalar x84, scalar x85, scalar x86, scalar x87, scalar x88, scalar x89, scalar x90, scalar x91, scalar x92, scalar x93, scalar x94, scalar x95, scalar x96, scalar x97, scalar x98, scalar x99) (mat10 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0], m[7, 0], m[8, 0], m[9, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1], m[7, 1], m[8, 1], m[9, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2], m[7, 2], m[8, 2], m[9, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3], m[7, 3], m[8, 3], m[9, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4], m[7, 4], m[8, 4], m[9, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5], m[7, 5], m[8, 5], m[9, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6], m[7, 6], m[8, 6], m[9, 6],
            m[0, 7], m[1, 7], m[2, 7], m[3, 7], m[4, 7], m[5, 7], m[6, 7], m[7, 7], m[8, 7], m[9, 7],
            m[0, 8], m[1, 8], m[2, 8], m[3, 8], m[4, 8], m[5, 8], m[6, 8], m[7, 8], m[8, 8], m[9, 8],
            m[0, 9], m[1, 9], m[2, 9], m[3, 9], m[4, 9], m[5, 9], m[6, 9], m[7, 9], m[8, 9], m[9, 9]
		);

		public static implicit operator mat10((scalar x00, scalar x01, scalar x02, scalar x03, scalar x04, scalar x05, scalar x06, scalar x07, scalar x08, scalar x09, scalar x10, scalar x11, scalar x12, scalar x13, scalar x14, scalar x15, scalar x16, scalar x17, scalar x18, scalar x19, scalar x20, scalar x21, scalar x22, scalar x23, scalar x24, scalar x25, scalar x26, scalar x27, scalar x28, scalar x29, scalar x30, scalar x31, scalar x32, scalar x33, scalar x34, scalar x35, scalar x36, scalar x37, scalar x38, scalar x39, scalar x40, scalar x41, scalar x42, scalar x43, scalar x44, scalar x45, scalar x46, scalar x47, scalar x48, scalar x49, scalar x50, scalar x51, scalar x52, scalar x53, scalar x54, scalar x55, scalar x56, scalar x57, scalar x58, scalar x59, scalar x60, scalar x61, scalar x62, scalar x63, scalar x64, scalar x65, scalar x66, scalar x67, scalar x68, scalar x69, scalar x70, scalar x71, scalar x72, scalar x73, scalar x74, scalar x75, scalar x76, scalar x77, scalar x78, scalar x79, scalar x80, scalar x81, scalar x82, scalar x83, scalar x84, scalar x85, scalar x86, scalar x87, scalar x88, scalar x89, scalar x90, scalar x91, scalar x92, scalar x93, scalar x94, scalar x95, scalar x96, scalar x97, scalar x98, scalar x99) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60, t.x70, t.x80, t.x90),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61, t.x71, t.x81, t.x91),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62, t.x72, t.x82, t.x92),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63, t.x73, t.x83, t.x93),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64, t.x74, t.x84, t.x94),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65, t.x75, t.x85, t.x95),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66, t.x76, t.x86, t.x96),
            (t.x07, t.x17, t.x27, t.x37, t.x47, t.x57, t.x67, t.x77, t.x87, t.x97),
            (t.x08, t.x18, t.x28, t.x38, t.x48, t.x58, t.x68, t.x78, t.x88, t.x98),
            (t.x09, t.x19, t.x29, t.x39, t.x49, t.x59, t.x69, t.x79, t.x89, t.x99)
		);

        public static explicit operator vec10[](mat10 m) => m.Columns;
		
        public static explicit operator scalar[](mat10 m) => m.ToArray();
		
        public static implicit operator mat10(vec10[] arr) => new mat10(arr);

        public static implicit operator mat10(scalar[] arr) => new mat10(arr);
    }

	#endregion
}
