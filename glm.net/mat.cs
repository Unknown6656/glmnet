// Autogenerated 2018-09-16 14:08:15.098383

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
	#region mat2

	/// <summary>
    /// Represents a square 2x2 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat2
        : imat<mat2, vec2>
    {
		private vec2 _c0;
		private vec2 _c1;

		
        /// <inheritdoc/>
        public vec2 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec2 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat2.Dimension;
		
        /// <inheritdoc/>
        public vec2[] Columns => new[] { _c0, _c1 };
		
        /// <inheritdoc/>
        public vec2[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat2 Transposed
        {
            get
            {
                mat2 r = mat2.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat2 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                det = 1 / det;

                return new mat2(
                    +this[1, 1] * det,
                    -this[0, 1] * det,
                    -this[1, 0] * det,
                    +this[0, 0] * det
                );
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1];

        /// <inheritdoc/>
        public mat2 OrthonormalBasis
        {
            get
            {
				vec2[] vs = new vec2[2];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 2;
		
	    /// <summary>
        /// The 2x2 zero matrix
        /// </summary>
        public static mat2 Zero { get; } = new mat2(0);
		
	    /// <summary>
        /// The 2x2 identity (unit) matrix
        /// </summary>
        public static mat2 Identity { get; } = new mat2(1);


        public mat2(float scale)
            : this((scale, 0),
				   (0, scale))
        {
        }

        public mat2(IEnumerable<vec2> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat2(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat2(vec2 v0, vec2 v1)
        {
			_c0 = v0;
			_c1 = v1;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat2 U, mat2 D) IwasawaDecompose()
        {
            mat2 ONB = OrthonormalBasis;
            mat2 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec2[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <inheritdoc/>
		public mat2 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat2 AddColumns(int src_col, int dst_col, float factor)
		{
            mat2 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat2 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat2 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat2 SwapColumns(int src_col, int dst_col)
		{
            vec2[] cols = Columns;
            vec2 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat2(cols);
		}
		
        /// <inheritdoc/>
		public mat2 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat2 mat && mat[0] == this[0] && mat[1] == this[1];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode();

		/// <summary>
		/// The 2x2-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat2 m1, mat2 m2) => m1.Equals(m2);

        public static bool operator !=(mat2 m1, mat2 m2) => !(m1 == m2);

        public static mat2 operator +(mat2 m) => m;

        public static mat2 operator -(mat2 m) => m * -1f;

        public static mat2 operator -(float f, mat2 m) => new mat2(f) - m;

        public static mat2 operator -(mat2 m, float f) => m + -f;

        public static mat2 operator +(float f, mat2 m) => m + f;

        public static mat2 operator +(mat2 m, float f) => m + new mat2(f);

        public static mat2 operator -(mat2 m1, mat2 m2) => m1 + -m2;

        public static mat2 operator +(mat2 m1, mat2 m2) => new mat2(m1[0] + m2[0], m1[1] + m2[1]);

        public static vec2 operator *(mat2 m, vec2 v) =>
			new vec2(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat2 operator *(mat2 m1, mat2 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat2(range.Select(j => new vec2(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat2 operator *(mat2 m, float f) => new mat2(m[0] * f, m[1] * f);

        public static mat2 operator /(mat2 m, float f) => m * (1 / f);

        public static implicit operator (vec2 x0, vec2 x1) (mat2 m) => (m[0], m[1]);

        public static implicit operator mat2((vec2 x0, vec2 x1) t) => new mat2(t.x0, t.x1);

        public static explicit operator ((float r0, float r1) c0, (float r0, float r1) c1) (mat2 m) => (m[0], m[1]);

        public static explicit operator mat2(((float r0, float r1) c0, (float r0, float r1) c1) t) => new mat2(t.c0, t.c1);

		public static implicit operator (float x00, float x01, float x10, float x11) (mat2 m) => (
            m[0, 0], m[1, 0],
            m[0, 1], m[1, 1]
		);

		public static implicit operator mat2((float x00, float x01, float x10, float x11) t) => (
            (t.x00, t.x10),
            (t.x01, t.x11)
		);

        public static explicit operator vec2[](mat2 m) => m.Columns;
		
        public static explicit operator float[](mat2 m) => m.ToArray();
		
        public static implicit operator mat2(vec2[] arr) => new mat2(arr);

        public static implicit operator mat2(float[] arr) => new mat2(arr);
    }

	#endregion
	#region mat3

	/// <summary>
    /// Represents a square 3x3 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat3
        : imat<mat3, vec3>
    {
		private vec3 _c0;
		private vec3 _c1;
		private vec3 _c2;

		
        /// <inheritdoc/>
        public vec3 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec3 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat3.Dimension;
		
        /// <inheritdoc/>
        public vec3[] Columns => new[] { _c0, _c1, _c2 };
		
        /// <inheritdoc/>
        public vec3[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat3 Transposed
        {
            get
            {
                mat3 r = mat3.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat3 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                det = 1 / det;

                return new mat3(0)
                {
                    [0, 0] = +(this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2]) * det,
                    [1, 0] = -(this[1, 0] * this[2, 2] - this[2, 0] * this[1, 2]) * det,
                    [2, 0] = +(this[1, 0] * this[2, 1] - this[2, 0] * this[1, 1]) * det,
                    [0, 1] = -(this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2]) * det,
                    [1, 1] = +(this[0, 0] * this[2, 2] - this[2, 0] * this[0, 2]) * det,
                    [2, 1] = -(this[0, 0] * this[2, 1] - this[2, 0] * this[0, 1]) * det,
                    [0, 2] = +(this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]) * det,
                    [1, 2] = -(this[0, 0] * this[1, 2] - this[1, 0] * this[0, 2]) * det,
                    [2, 2] = +(this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1]) * det
                };
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => this[0, 0] * (this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2])
								  - this[1, 0] * (this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2])
								  + this[2, 0] * (this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]);

        /// <inheritdoc/>
        public mat3 OrthonormalBasis
        {
            get
            {
				vec3[] vs = new vec3[3];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 3;
		
	    /// <summary>
        /// The 3x3 zero matrix
        /// </summary>
        public static mat3 Zero { get; } = new mat3(0);
		
	    /// <summary>
        /// The 3x3 identity (unit) matrix
        /// </summary>
        public static mat3 Identity { get; } = new mat3(1);


        public mat3(float scale)
            : this((scale, 0, 0),
				   (0, scale, 0),
				   (0, 0, scale))
        {
        }

        public mat3(IEnumerable<vec3> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat3(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat3(vec3 v0, vec3 v1, vec3 v2)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat3 U, mat3 D) IwasawaDecompose()
        {
            mat3 ONB = OrthonormalBasis;
            mat3 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec3[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the matrix' 2x2-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>2x2-minor</returns>
        public mat2 Minor(int column, int row) => new mat2(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec2(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat3 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat3 AddColumns(int src_col, int dst_col, float factor)
		{
            mat3 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat3 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat3 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat3 SwapColumns(int src_col, int dst_col)
		{
            vec3[] cols = Columns;
            vec3 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat3(cols);
		}
		
        /// <inheritdoc/>
		public mat3 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat3 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode();

		/// <summary>
		/// The 3x3-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat3 m1, mat3 m2) => m1.Equals(m2);

        public static bool operator !=(mat3 m1, mat3 m2) => !(m1 == m2);

        public static mat3 operator +(mat3 m) => m;

        public static mat3 operator -(mat3 m) => m * -1f;

        public static mat3 operator -(float f, mat3 m) => new mat3(f) - m;

        public static mat3 operator -(mat3 m, float f) => m + -f;

        public static mat3 operator +(float f, mat3 m) => m + f;

        public static mat3 operator +(mat3 m, float f) => m + new mat3(f);

        public static mat3 operator -(mat3 m1, mat3 m2) => m1 + -m2;

        public static mat3 operator +(mat3 m1, mat3 m2) => new mat3(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2]);

        public static vec3 operator *(mat3 m, vec3 v) =>
			new vec3(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat3 operator *(mat3 m1, mat3 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat3(range.Select(j => new vec3(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat3 operator *(mat3 m, float f) => new mat3(m[0] * f, m[1] * f, m[2] * f);

        public static mat3 operator /(mat3 m, float f) => m * (1 / f);

        public static implicit operator (vec3 x0, vec3 x1, vec3 x2) (mat3 m) => (m[0], m[1], m[2]);

        public static implicit operator mat3((vec3 x0, vec3 x1, vec3 x2) t) => new mat3(t.x0, t.x1, t.x2);

        public static explicit operator ((float r0, float r1, float r2) c0, (float r0, float r1, float r2) c1, (float r0, float r1, float r2) c2) (mat3 m) => (m[0], m[1], m[2]);

        public static explicit operator mat3(((float r0, float r1, float r2) c0, (float r0, float r1, float r2) c1, (float r0, float r1, float r2) c2) t) => new mat3(t.c0, t.c1, t.c2);

		public static implicit operator (float x00, float x01, float x02, float x10, float x11, float x12, float x20, float x21, float x22) (mat3 m) => (
            m[0, 0], m[1, 0], m[2, 0],
            m[0, 1], m[1, 1], m[2, 1],
            m[0, 2], m[1, 2], m[2, 2]
		);

		public static implicit operator mat3((float x00, float x01, float x02, float x10, float x11, float x12, float x20, float x21, float x22) t) => (
            (t.x00, t.x10, t.x20),
            (t.x01, t.x11, t.x21),
            (t.x02, t.x12, t.x22)
		);

        public static explicit operator vec3[](mat3 m) => m.Columns;
		
        public static explicit operator float[](mat3 m) => m.ToArray();
		
        public static implicit operator mat3(vec3[] arr) => new mat3(arr);

        public static implicit operator mat3(float[] arr) => new mat3(arr);
    }

	#endregion
	#region mat4

	/// <summary>
    /// Represents a square 4x4 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat4
        : imat<mat4, vec4>
    {
		private vec4 _c0;
		private vec4 _c1;
		private vec4 _c2;
		private vec4 _c3;

		
        /// <inheritdoc/>
        public vec4 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec4 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat4.Dimension;
		
        /// <inheritdoc/>
        public vec4[] Columns => new[] { _c0, _c1, _c2, _c3 };
		
        /// <inheritdoc/>
        public vec4[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat4 Transposed
        {
            get
            {
                mat4 r = mat4.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat4 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant;

        /// <inheritdoc/>
        public mat4 OrthonormalBasis
        {
            get
            {
				vec4[] vs = new vec4[4];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 4;
		
	    /// <summary>
        /// The 4x4 zero matrix
        /// </summary>
        public static mat4 Zero { get; } = new mat4(0);
		
	    /// <summary>
        /// The 4x4 identity (unit) matrix
        /// </summary>
        public static mat4 Identity { get; } = new mat4(1);


        public mat4(float scale)
            : this((scale, 0, 0, 0),
				   (0, scale, 0, 0),
				   (0, 0, scale, 0),
				   (0, 0, 0, scale))
        {
        }

        public mat4(IEnumerable<vec4> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat4(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat4(vec4 v0, vec4 v1, vec4 v2, vec4 v3)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat4 U, mat4 D) IwasawaDecompose()
        {
            mat4 ONB = OrthonormalBasis;
            mat4 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec4[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the matrix' 3x3-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>3x3-minor</returns>
        public mat3 Minor(int column, int row) => new mat3(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec3(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat4 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat4 AddColumns(int src_col, int dst_col, float factor)
		{
            mat4 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat4 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat4 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat4 SwapColumns(int src_col, int dst_col)
		{
            vec4[] cols = Columns;
            vec4 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat4(cols);
		}
		
        /// <inheritdoc/>
		public mat4 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat4 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode();

		/// <summary>
		/// The 4x4-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat4 m1, mat4 m2) => m1.Equals(m2);

        public static bool operator !=(mat4 m1, mat4 m2) => !(m1 == m2);

        public static mat4 operator +(mat4 m) => m;

        public static mat4 operator -(mat4 m) => m * -1f;

        public static mat4 operator -(float f, mat4 m) => new mat4(f) - m;

        public static mat4 operator -(mat4 m, float f) => m + -f;

        public static mat4 operator +(float f, mat4 m) => m + f;

        public static mat4 operator +(mat4 m, float f) => m + new mat4(f);

        public static mat4 operator -(mat4 m1, mat4 m2) => m1 + -m2;

        public static mat4 operator +(mat4 m1, mat4 m2) => new mat4(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3]);

        public static vec4 operator *(mat4 m, vec4 v) =>
			new vec4(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat4 operator *(mat4 m1, mat4 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat4(range.Select(j => new vec4(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat4 operator *(mat4 m, float f) => new mat4(m[0] * f, m[1] * f, m[2] * f, m[3] * f);

        public static mat4 operator /(mat4 m, float f) => m * (1 / f);

        public static implicit operator (vec4 x0, vec4 x1, vec4 x2, vec4 x3) (mat4 m) => (m[0], m[1], m[2], m[3]);

        public static implicit operator mat4((vec4 x0, vec4 x1, vec4 x2, vec4 x3) t) => new mat4(t.x0, t.x1, t.x2, t.x3);

        public static explicit operator ((float r0, float r1, float r2, float r3) c0, (float r0, float r1, float r2, float r3) c1, (float r0, float r1, float r2, float r3) c2, (float r0, float r1, float r2, float r3) c3) (mat4 m) => (m[0], m[1], m[2], m[3]);

        public static explicit operator mat4(((float r0, float r1, float r2, float r3) c0, (float r0, float r1, float r2, float r3) c1, (float r0, float r1, float r2, float r3) c2, (float r0, float r1, float r2, float r3) c3) t) => new mat4(t.c0, t.c1, t.c2, t.c3);

		public static implicit operator (float x00, float x01, float x02, float x03, float x10, float x11, float x12, float x13, float x20, float x21, float x22, float x23, float x30, float x31, float x32, float x33) (mat4 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3]
		);

		public static implicit operator mat4((float x00, float x01, float x02, float x03, float x10, float x11, float x12, float x13, float x20, float x21, float x22, float x23, float x30, float x31, float x32, float x33) t) => (
            (t.x00, t.x10, t.x20, t.x30),
            (t.x01, t.x11, t.x21, t.x31),
            (t.x02, t.x12, t.x22, t.x32),
            (t.x03, t.x13, t.x23, t.x33)
		);

        public static explicit operator vec4[](mat4 m) => m.Columns;
		
        public static explicit operator float[](mat4 m) => m.ToArray();
		
        public static implicit operator mat4(vec4[] arr) => new mat4(arr);

        public static implicit operator mat4(float[] arr) => new mat4(arr);
    }

	#endregion
	#region mat5

	/// <summary>
    /// Represents a square 5x5 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat5
        : imat<mat5, vec5>
    {
		private vec5 _c0;
		private vec5 _c1;
		private vec5 _c2;
		private vec5 _c3;
		private vec5 _c4;

		
        /// <inheritdoc/>
        public vec5 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec5 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat5.Dimension;
		
        /// <inheritdoc/>
        public vec5[] Columns => new[] { _c0, _c1, _c2, _c3, _c4 };
		
        /// <inheritdoc/>
        public vec5[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat5 Transposed
        {
            get
            {
                mat5 r = mat5.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat5 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant;

        /// <inheritdoc/>
        public mat5 OrthonormalBasis
        {
            get
            {
				vec5[] vs = new vec5[5];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 5;
		
	    /// <summary>
        /// The 5x5 zero matrix
        /// </summary>
        public static mat5 Zero { get; } = new mat5(0);
		
	    /// <summary>
        /// The 5x5 identity (unit) matrix
        /// </summary>
        public static mat5 Identity { get; } = new mat5(1);


        public mat5(float scale)
            : this((scale, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0),
				   (0, 0, scale, 0, 0),
				   (0, 0, 0, scale, 0),
				   (0, 0, 0, 0, scale))
        {
        }

        public mat5(IEnumerable<vec5> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat5(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat5(vec5 v0, vec5 v1, vec5 v2, vec5 v3, vec5 v4)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat5 U, mat5 D) IwasawaDecompose()
        {
            mat5 ONB = OrthonormalBasis;
            mat5 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec5[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the matrix' 4x4-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>4x4-minor</returns>
        public mat4 Minor(int column, int row) => new mat4(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec4(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat5 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat5 AddColumns(int src_col, int dst_col, float factor)
		{
            mat5 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat5 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat5 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat5 SwapColumns(int src_col, int dst_col)
		{
            vec5[] cols = Columns;
            vec5 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat5(cols);
		}
		
        /// <inheritdoc/>
		public mat5 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat5 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode();

		/// <summary>
		/// The 5x5-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat5 m1, mat5 m2) => m1.Equals(m2);

        public static bool operator !=(mat5 m1, mat5 m2) => !(m1 == m2);

        public static mat5 operator +(mat5 m) => m;

        public static mat5 operator -(mat5 m) => m * -1f;

        public static mat5 operator -(float f, mat5 m) => new mat5(f) - m;

        public static mat5 operator -(mat5 m, float f) => m + -f;

        public static mat5 operator +(float f, mat5 m) => m + f;

        public static mat5 operator +(mat5 m, float f) => m + new mat5(f);

        public static mat5 operator -(mat5 m1, mat5 m2) => m1 + -m2;

        public static mat5 operator +(mat5 m1, mat5 m2) => new mat5(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4]);

        public static vec5 operator *(mat5 m, vec5 v) =>
			new vec5(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat5 operator *(mat5 m1, mat5 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat5(range.Select(j => new vec5(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat5 operator *(mat5 m, float f) => new mat5(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f);

        public static mat5 operator /(mat5 m, float f) => m * (1 / f);

        public static implicit operator (vec5 x0, vec5 x1, vec5 x2, vec5 x3, vec5 x4) (mat5 m) => (m[0], m[1], m[2], m[3], m[4]);

        public static implicit operator mat5((vec5 x0, vec5 x1, vec5 x2, vec5 x3, vec5 x4) t) => new mat5(t.x0, t.x1, t.x2, t.x3, t.x4);

        public static explicit operator ((float r0, float r1, float r2, float r3, float r4) c0, (float r0, float r1, float r2, float r3, float r4) c1, (float r0, float r1, float r2, float r3, float r4) c2, (float r0, float r1, float r2, float r3, float r4) c3, (float r0, float r1, float r2, float r3, float r4) c4) (mat5 m) => (m[0], m[1], m[2], m[3], m[4]);

        public static explicit operator mat5(((float r0, float r1, float r2, float r3, float r4) c0, (float r0, float r1, float r2, float r3, float r4) c1, (float r0, float r1, float r2, float r3, float r4) c2, (float r0, float r1, float r2, float r3, float r4) c3, (float r0, float r1, float r2, float r3, float r4) c4) t) => new mat5(t.c0, t.c1, t.c2, t.c3, t.c4);

		public static implicit operator (float x00, float x01, float x02, float x03, float x04, float x10, float x11, float x12, float x13, float x14, float x20, float x21, float x22, float x23, float x24, float x30, float x31, float x32, float x33, float x34, float x40, float x41, float x42, float x43, float x44) (mat5 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4]
		);

		public static implicit operator mat5((float x00, float x01, float x02, float x03, float x04, float x10, float x11, float x12, float x13, float x14, float x20, float x21, float x22, float x23, float x24, float x30, float x31, float x32, float x33, float x34, float x40, float x41, float x42, float x43, float x44) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40),
            (t.x01, t.x11, t.x21, t.x31, t.x41),
            (t.x02, t.x12, t.x22, t.x32, t.x42),
            (t.x03, t.x13, t.x23, t.x33, t.x43),
            (t.x04, t.x14, t.x24, t.x34, t.x44)
		);

        public static explicit operator vec5[](mat5 m) => m.Columns;
		
        public static explicit operator float[](mat5 m) => m.ToArray();
		
        public static implicit operator mat5(vec5[] arr) => new mat5(arr);

        public static implicit operator mat5(float[] arr) => new mat5(arr);
    }

	#endregion
	#region mat6

	/// <summary>
    /// Represents a square 6x6 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat6
        : imat<mat6, vec6>
    {
		private vec6 _c0;
		private vec6 _c1;
		private vec6 _c2;
		private vec6 _c3;
		private vec6 _c4;
		private vec6 _c5;

		
        /// <inheritdoc/>
        public vec6 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec6 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat6.Dimension;
		
        /// <inheritdoc/>
        public vec6[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5 };
		
        /// <inheritdoc/>
        public vec6[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat6 Transposed
        {
            get
            {
                mat6 r = mat6.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat6 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant;

        /// <inheritdoc/>
        public mat6 OrthonormalBasis
        {
            get
            {
				vec6[] vs = new vec6[6];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 6;
		
	    /// <summary>
        /// The 6x6 zero matrix
        /// </summary>
        public static mat6 Zero { get; } = new mat6(0);
		
	    /// <summary>
        /// The 6x6 identity (unit) matrix
        /// </summary>
        public static mat6 Identity { get; } = new mat6(1);


        public mat6(float scale)
            : this((scale, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, scale))
        {
        }

        public mat6(IEnumerable<vec6> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat6(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat6(vec6 v0, vec6 v1, vec6 v2, vec6 v3, vec6 v4, vec6 v5)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat6 U, mat6 D) IwasawaDecompose()
        {
            mat6 ONB = OrthonormalBasis;
            mat6 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec6[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the matrix' 5x5-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>5x5-minor</returns>
        public mat5 Minor(int column, int row) => new mat5(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec5(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat6 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat6 AddColumns(int src_col, int dst_col, float factor)
		{
            mat6 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat6 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat6 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat6 SwapColumns(int src_col, int dst_col)
		{
            vec6[] cols = Columns;
            vec6 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat6(cols);
		}
		
        /// <inheritdoc/>
		public mat6 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat6 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode();

		/// <summary>
		/// The 6x6-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat6 m1, mat6 m2) => m1.Equals(m2);

        public static bool operator !=(mat6 m1, mat6 m2) => !(m1 == m2);

        public static mat6 operator +(mat6 m) => m;

        public static mat6 operator -(mat6 m) => m * -1f;

        public static mat6 operator -(float f, mat6 m) => new mat6(f) - m;

        public static mat6 operator -(mat6 m, float f) => m + -f;

        public static mat6 operator +(float f, mat6 m) => m + f;

        public static mat6 operator +(mat6 m, float f) => m + new mat6(f);

        public static mat6 operator -(mat6 m1, mat6 m2) => m1 + -m2;

        public static mat6 operator +(mat6 m1, mat6 m2) => new mat6(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5]);

        public static vec6 operator *(mat6 m, vec6 v) =>
			new vec6(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat6 operator *(mat6 m1, mat6 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat6(range.Select(j => new vec6(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat6 operator *(mat6 m, float f) => new mat6(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f);

        public static mat6 operator /(mat6 m, float f) => m * (1 / f);

        public static implicit operator (vec6 x0, vec6 x1, vec6 x2, vec6 x3, vec6 x4, vec6 x5) (mat6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

        public static implicit operator mat6((vec6 x0, vec6 x1, vec6 x2, vec6 x3, vec6 x4, vec6 x5) t) => new mat6(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);

        public static explicit operator ((float r0, float r1, float r2, float r3, float r4, float r5) c0, (float r0, float r1, float r2, float r3, float r4, float r5) c1, (float r0, float r1, float r2, float r3, float r4, float r5) c2, (float r0, float r1, float r2, float r3, float r4, float r5) c3, (float r0, float r1, float r2, float r3, float r4, float r5) c4, (float r0, float r1, float r2, float r3, float r4, float r5) c5) (mat6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

        public static explicit operator mat6(((float r0, float r1, float r2, float r3, float r4, float r5) c0, (float r0, float r1, float r2, float r3, float r4, float r5) c1, (float r0, float r1, float r2, float r3, float r4, float r5) c2, (float r0, float r1, float r2, float r3, float r4, float r5) c3, (float r0, float r1, float r2, float r3, float r4, float r5) c4, (float r0, float r1, float r2, float r3, float r4, float r5) c5) t) => new mat6(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5);

		public static implicit operator (float x00, float x01, float x02, float x03, float x04, float x05, float x10, float x11, float x12, float x13, float x14, float x15, float x20, float x21, float x22, float x23, float x24, float x25, float x30, float x31, float x32, float x33, float x34, float x35, float x40, float x41, float x42, float x43, float x44, float x45, float x50, float x51, float x52, float x53, float x54, float x55) (mat6 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5]
		);

		public static implicit operator mat6((float x00, float x01, float x02, float x03, float x04, float x05, float x10, float x11, float x12, float x13, float x14, float x15, float x20, float x21, float x22, float x23, float x24, float x25, float x30, float x31, float x32, float x33, float x34, float x35, float x40, float x41, float x42, float x43, float x44, float x45, float x50, float x51, float x52, float x53, float x54, float x55) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55)
		);

        public static explicit operator vec6[](mat6 m) => m.Columns;
		
        public static explicit operator float[](mat6 m) => m.ToArray();
		
        public static implicit operator mat6(vec6[] arr) => new mat6(arr);

        public static implicit operator mat6(float[] arr) => new mat6(arr);
    }

	#endregion
	#region mat7

	/// <summary>
    /// Represents a square 7x7 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat7
        : imat<mat7, vec7>
    {
		private vec7 _c0;
		private vec7 _c1;
		private vec7 _c2;
		private vec7 _c3;
		private vec7 _c4;
		private vec7 _c5;
		private vec7 _c6;

		
        /// <inheritdoc/>
        public vec7 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec7 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat7.Dimension;
		
        /// <inheritdoc/>
        public vec7[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6 };
		
        /// <inheritdoc/>
        public vec7[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat7 Transposed
        {
            get
            {
                mat7 r = mat7.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat7 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant;

        /// <inheritdoc/>
        public mat7 OrthonormalBasis
        {
            get
            {
				vec7[] vs = new vec7[7];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 7;
		
	    /// <summary>
        /// The 7x7 zero matrix
        /// </summary>
        public static mat7 Zero { get; } = new mat7(0);
		
	    /// <summary>
        /// The 7x7 identity (unit) matrix
        /// </summary>
        public static mat7 Identity { get; } = new mat7(1);


        public mat7(float scale)
            : this((scale, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat7(IEnumerable<vec7> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat7(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat7(vec7 v0, vec7 v1, vec7 v2, vec7 v3, vec7 v4, vec7 v5, vec7 v6)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat7 U, mat7 D) IwasawaDecompose()
        {
            mat7 ONB = OrthonormalBasis;
            mat7 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec7[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the matrix' 6x6-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>6x6-minor</returns>
        public mat6 Minor(int column, int row) => new mat6(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec6(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat7 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat7 AddColumns(int src_col, int dst_col, float factor)
		{
            mat7 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat7 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat7 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat7 SwapColumns(int src_col, int dst_col)
		{
            vec7[] cols = Columns;
            vec7 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat7(cols);
		}
		
        /// <inheritdoc/>
		public mat7 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat7 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode();

		/// <summary>
		/// The 7x7-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat7 m1, mat7 m2) => m1.Equals(m2);

        public static bool operator !=(mat7 m1, mat7 m2) => !(m1 == m2);

        public static mat7 operator +(mat7 m) => m;

        public static mat7 operator -(mat7 m) => m * -1f;

        public static mat7 operator -(float f, mat7 m) => new mat7(f) - m;

        public static mat7 operator -(mat7 m, float f) => m + -f;

        public static mat7 operator +(float f, mat7 m) => m + f;

        public static mat7 operator +(mat7 m, float f) => m + new mat7(f);

        public static mat7 operator -(mat7 m1, mat7 m2) => m1 + -m2;

        public static mat7 operator +(mat7 m1, mat7 m2) => new mat7(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6]);

        public static vec7 operator *(mat7 m, vec7 v) =>
			new vec7(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat7 operator *(mat7 m1, mat7 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat7(range.Select(j => new vec7(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat7 operator *(mat7 m, float f) => new mat7(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f);

        public static mat7 operator /(mat7 m, float f) => m * (1 / f);

        public static implicit operator (vec7 x0, vec7 x1, vec7 x2, vec7 x3, vec7 x4, vec7 x5, vec7 x6) (mat7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

        public static implicit operator mat7((vec7 x0, vec7 x1, vec7 x2, vec7 x3, vec7 x4, vec7 x5, vec7 x6) t) => new mat7(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);

        public static explicit operator ((float r0, float r1, float r2, float r3, float r4, float r5, float r6) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c6) (mat7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

        public static explicit operator mat7(((float r0, float r1, float r2, float r3, float r4, float r5, float r6) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6) c6) t) => new mat7(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6);

		public static implicit operator (float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x60, float x61, float x62, float x63, float x64, float x65, float x66) (mat7 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6]
		);

		public static implicit operator mat7((float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x60, float x61, float x62, float x63, float x64, float x65, float x66) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66)
		);

        public static explicit operator vec7[](mat7 m) => m.Columns;
		
        public static explicit operator float[](mat7 m) => m.ToArray();
		
        public static implicit operator mat7(vec7[] arr) => new mat7(arr);

        public static implicit operator mat7(float[] arr) => new mat7(arr);
    }

	#endregion
	#region mat8

	/// <summary>
    /// Represents a square 8x8 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat8
        : imat<mat8, vec8>
    {
		private vec8 _c0;
		private vec8 _c1;
		private vec8 _c2;
		private vec8 _c3;
		private vec8 _c4;
		private vec8 _c5;
		private vec8 _c6;
		private vec8 _c7;

		
        /// <inheritdoc/>
        public vec8 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
					case 7: return _c7;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
				else if (column == 7) _c7 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec8 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat8.Dimension;
		
        /// <inheritdoc/>
        public vec8[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7 };
		
        /// <inheritdoc/>
        public vec8[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat8 Transposed
        {
            get
            {
                mat8 r = mat8.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat8 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant
									- Minor(0, 7).Determinant;

        /// <inheritdoc/>
        public mat8 OrthonormalBasis
        {
            get
            {
				vec8[] vs = new vec8[8];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 8;
		
	    /// <summary>
        /// The 8x8 zero matrix
        /// </summary>
        public static mat8 Zero { get; } = new mat8(0);
		
	    /// <summary>
        /// The 8x8 identity (unit) matrix
        /// </summary>
        public static mat8 Identity { get; } = new mat8(1);


        public mat8(float scale)
            : this((scale, 0, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat8(IEnumerable<vec8> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat8(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat8(vec8 v0, vec8 v1, vec8 v2, vec8 v3, vec8 v4, vec8 v5, vec8 v6, vec8 v7)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
			_c7 = v7;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat8 U, mat8 D) IwasawaDecompose()
        {
            mat8 ONB = OrthonormalBasis;
            mat8 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec8[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>7x7 sub-matrix</returns>
        public mat7 ToMatix7() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6])
		);

        /// <summary>
        /// Returns the matrix' 7x7-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>7x7-minor</returns>
        public mat7 Minor(int column, int row) => new mat7(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec7(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat8 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat8 AddColumns(int src_col, int dst_col, float factor)
		{
            mat8 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat8 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat8 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat8 SwapColumns(int src_col, int dst_col)
		{
            vec8[] cols = Columns;
            vec8 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat8(cols);
		}
		
        /// <inheritdoc/>
		public mat8 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat8 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6] && mat[7] == this[7];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode() ^ _c7.GetHashCode();

		/// <summary>
		/// The 8x8-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat8 m1, mat8 m2) => m1.Equals(m2);

        public static bool operator !=(mat8 m1, mat8 m2) => !(m1 == m2);

        public static mat8 operator +(mat8 m) => m;

        public static mat8 operator -(mat8 m) => m * -1f;

        public static mat8 operator -(float f, mat8 m) => new mat8(f) - m;

        public static mat8 operator -(mat8 m, float f) => m + -f;

        public static mat8 operator +(float f, mat8 m) => m + f;

        public static mat8 operator +(mat8 m, float f) => m + new mat8(f);

        public static mat8 operator -(mat8 m1, mat8 m2) => m1 + -m2;

        public static mat8 operator +(mat8 m1, mat8 m2) => new mat8(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7]);

        public static vec8 operator *(mat8 m, vec8 v) =>
			new vec8(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat8 operator *(mat8 m1, mat8 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat8(range.Select(j => new vec8(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat8 operator *(mat8 m, float f) => new mat8(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f, m[7] * f);

        public static mat8 operator /(mat8 m, float f) => m * (1 / f);

        public static implicit operator (vec8 x0, vec8 x1, vec8 x2, vec8 x3, vec8 x4, vec8 x5, vec8 x6, vec8 x7) (mat8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

        public static implicit operator mat8((vec8 x0, vec8 x1, vec8 x2, vec8 x3, vec8 x4, vec8 x5, vec8 x6, vec8 x7) t) => new mat8(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);

        public static explicit operator ((float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c6, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c7) (mat8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

        public static explicit operator mat8(((float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c6, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7) c7) t) => new mat8(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7);

		public static implicit operator (float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x07, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x17, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x27, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x37, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x47, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x57, float x60, float x61, float x62, float x63, float x64, float x65, float x66, float x67, float x70, float x71, float x72, float x73, float x74, float x75, float x76, float x77) (mat8 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0], m[7, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1], m[7, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2], m[7, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3], m[7, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4], m[7, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5], m[7, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6], m[7, 6],
            m[0, 7], m[1, 7], m[2, 7], m[3, 7], m[4, 7], m[5, 7], m[6, 7], m[7, 7]
		);

		public static implicit operator mat8((float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x07, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x17, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x27, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x37, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x47, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x57, float x60, float x61, float x62, float x63, float x64, float x65, float x66, float x67, float x70, float x71, float x72, float x73, float x74, float x75, float x76, float x77) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60, t.x70),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61, t.x71),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62, t.x72),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63, t.x73),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64, t.x74),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65, t.x75),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66, t.x76),
            (t.x07, t.x17, t.x27, t.x37, t.x47, t.x57, t.x67, t.x77)
		);

        public static explicit operator vec8[](mat8 m) => m.Columns;
		
        public static explicit operator float[](mat8 m) => m.ToArray();
		
        public static implicit operator mat8(vec8[] arr) => new mat8(arr);

        public static implicit operator mat8(float[] arr) => new mat8(arr);
    }

	#endregion
	#region mat9

	/// <summary>
    /// Represents a square 9x9 matrix.
    /// </summary>
    /// <inheritdoc cref="imat{M,V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct mat9
        : imat<mat9, vec9>
    {
		private vec9 _c0;
		private vec9 _c1;
		private vec9 _c2;
		private vec9 _c3;
		private vec9 _c4;
		private vec9 _c5;
		private vec9 _c6;
		private vec9 _c7;
		private vec9 _c8;

		
        /// <inheritdoc/>
        public vec9 this[int column]
        {
			get
            {
                switch (column)
                {
					case 0: return _c0;
					case 1: return _c1;
					case 2: return _c2;
					case 3: return _c3;
					case 4: return _c4;
					case 5: return _c5;
					case 6: return _c6;
					case 7: return _c7;
					case 8: return _c8;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (column == 0) _c0 = value;
				else if (column == 1) _c1 = value;
				else if (column == 2) _c2 = value;
				else if (column == 3) _c3 = value;
				else if (column == 4) _c4 = value;
				else if (column == 5) _c5 = value;
				else if (column == 6) _c6 = value;
				else if (column == 7) _c7 = value;
				else if (column == 8) _c8 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public float this[int column, int row]
        {
            get => this[column][row];
            set
			{
				vec9 v = this[column];
				
				v[row] = value;
				this[column] = v;
			}
        }
		
        /// <inheritdoc/>
        public bool IsInvertible => Math.Abs(Determinant) >= float.Epsilon;
		
        /// <inheritdoc/>
        public bool IsSymetric => this == Transposed;
		
        /// <inheritdoc/>
        public bool IsProjection => this == this * this;
		
        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;
		
        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;
		
        /// <inheritdoc/>
        public bool IsSkewSymetric => this == -Transposed;
		
        /// <inheritdoc/>
        public int Size => mat9.Dimension;
		
        /// <inheritdoc/>
        public vec9[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8 };
		
        /// <inheritdoc/>
        public vec9[] Rows => Transposed.Columns;
		
        /// <inheritdoc/>
        public mat9 Transposed
        {
            get
            {
                mat9 r = mat9.Zero;

                for (int i = 0; i < Dimension; ++i)
                    for (int j = 0; j < Dimension; ++j)
                        r[i, j] = this[j, i];

                return r;
            }
        }
		
        /// <inheritdoc/>
        public mat9 Inverse
        {
            get
            {
			    float det = Determinant;

				if (det.is_zero())
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

                throw new NotImplementedException();
			}
		}
		
        /// <inheritdoc/>
        public float Determinant => + Minor(0, 0).Determinant
									- Minor(0, 1).Determinant
									+ Minor(0, 2).Determinant
									- Minor(0, 3).Determinant
									+ Minor(0, 4).Determinant
									- Minor(0, 5).Determinant
									+ Minor(0, 6).Determinant
									- Minor(0, 7).Determinant
									+ Minor(0, 8).Determinant;

        /// <inheritdoc/>
        public mat9 OrthonormalBasis
        {
            get
            {
				vec9[] vs = new vec9[9];

				for (int i = 0; i < Dimension; ++i)
				{
					vs[i] = this[i];

					for (int j = 0; j < i; ++ j)
						vs[i] -= this[j].Dot(vs[j]) * vs[j];

					vs[i] = vs[i].Normalized;
				}

                return vs;
            }
        }
		
        /// <inheritdoc/>
        public poly CharacteristicPolynomial => throw new NotImplementedException();
		
        /// <inheritdoc/>
        public int Rank => throw new NotImplementedException();

		
        /// <inheritdoc cref="imat{M,V}.Size"/>
        public static int Dimension { get; } = 9;
		
	    /// <summary>
        /// The 9x9 zero matrix
        /// </summary>
        public static mat9 Zero { get; } = new mat9(0);
		
	    /// <summary>
        /// The 9x9 identity (unit) matrix
        /// </summary>
        public static mat9 Identity { get; } = new mat9(1);


        public mat9(float scale)
            : this((scale, 0, 0, 0, 0, 0, 0, 0, 0),
				   (0, scale, 0, 0, 0, 0, 0, 0, 0),
				   (0, 0, scale, 0, 0, 0, 0, 0, 0),
				   (0, 0, 0, scale, 0, 0, 0, 0, 0),
				   (0, 0, 0, 0, scale, 0, 0, 0, 0),
				   (0, 0, 0, 0, 0, scale, 0, 0, 0),
				   (0, 0, 0, 0, 0, 0, scale, 0, 0),
				   (0, 0, 0, 0, 0, 0, 0, scale, 0),
				   (0, 0, 0, 0, 0, 0, 0, 0, scale))
        {
        }

        public mat9(IEnumerable<vec9> cols)
			: this() => FromArray(cols.Take(Dimension).ToArray());

        public mat9(params float[] values)
			: this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public mat9(vec9 v0, vec9 v1, vec9 v2, vec9 v3, vec9 v4, vec9 v5, vec9 v6, vec9 v7, vec9 v8)
        {
			_c0 = v0;
			_c1 = v1;
			_c2 = v2;
			_c3 = v3;
			_c4 = v4;
			_c5 = v5;
			_c6 = v6;
			_c7 = v7;
			_c8 = v8;
        }
		

		/* TODO : fix
        public (mat3 L, mat3 U) LUDecompose()
        {
            mat3 U = (mat3)Clone();
            float k21 = U[0, 1] / U[0, 0];
            float k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<mat3, vec3>(0, 2, -k31));

            float k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<mat3, vec3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
		*/

        public (mat9 U, mat9 D) IwasawaDecompose()
        {
            mat9 ONB = OrthonormalBasis;
            mat9 D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public void FromArray(float[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension * Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension * Dimension}.", nameof(arr));
				
			for (int i = 0; i < Dimension * Dimension; ++i)
			    this[i % Dimension, i / Dimension] = arr[i];
		}
		
        /// <inheritdoc/>
        public void FromArray(vec9[] arr)
		{
		    if (arr is null)
			    throw new ArgumentNullException(nameof(arr));
			if (arr.Length != Dimension)
			    throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr));

			for (int i = 0; i < Dimension; ++i)
			    this[i] = arr[i];
		}

        /// <inheritdoc/>
        public float[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();

        /// <summary>
        /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>2x2 sub-matrix</returns>
        public mat2 ToMatix2() => (
			(_c0[0], _c0[1]),
			(_c1[0], _c1[1])
		);

        /// <summary>
        /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>3x3 sub-matrix</returns>
        public mat3 ToMatix3() => (
			(_c0[0], _c0[1], _c0[2]),
			(_c1[0], _c1[1], _c1[2]),
			(_c2[0], _c2[1], _c2[2])
		);

        /// <summary>
        /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>4x4 sub-matrix</returns>
        public mat4 ToMatix4() => (
			(_c0[0], _c0[1], _c0[2], _c0[3]),
			(_c1[0], _c1[1], _c1[2], _c1[3]),
			(_c2[0], _c2[1], _c2[2], _c2[3]),
			(_c3[0], _c3[1], _c3[2], _c3[3])
		);

        /// <summary>
        /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>5x5 sub-matrix</returns>
        public mat5 ToMatix5() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4])
		);

        /// <summary>
        /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>6x6 sub-matrix</returns>
        public mat6 ToMatix6() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5])
		);

        /// <summary>
        /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>7x7 sub-matrix</returns>
        public mat7 ToMatix7() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6])
		);

        /// <summary>
        /// Returns the upper-left 8x8 sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns>8x8 sub-matrix</returns>
        public mat8 ToMatix8() => (
			(_c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7]),
			(_c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7]),
			(_c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7]),
			(_c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7]),
			(_c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7]),
			(_c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7]),
			(_c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7]),
			(_c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7])
		);

        /// <summary>
        /// Returns the matrix' 8x8-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns>8x8-minor</returns>
        public mat8 Minor(int column, int row) => new mat8(
			Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
			{
				float[] f = v.ToArray();

				return new vec8(f.Take(row).Concat(f.Skip(row + 1)));
			}));

        /// <inheritdoc/>
		public mat9 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);
		
        /// <inheritdoc/>
		public mat9 AddColumns(int src_col, int dst_col, float factor)
		{
            mat9 res = this;

            res[dst_col] += res[src_col] * factor;

            return res;
		}
		
        /// <inheritdoc/>
		public mat9 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);
		
        /// <inheritdoc/>
		public mat9 AddRows(int src_row, int dst_row, float factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;
		
        /// <inheritdoc/>
		public mat9 SwapColumns(int src_col, int dst_col)
		{
            vec9[] cols = Columns;
            vec9 tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new mat9(cols);
		}
		
        /// <inheritdoc/>
		public mat9 SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is mat9 mat && mat[0] == this[0] && mat[1] == this[1] && mat[2] == this[2] && mat[3] == this[3] && mat[4] == this[4] && mat[5] == this[5] && mat[6] == this[6] && mat[7] == this[7] && mat[8] == this[8];

        /// <inheritdoc/>
        public override int GetHashCode() => _c0.GetHashCode() ^ _c1.GetHashCode() ^ _c2.GetHashCode() ^ _c3.GetHashCode() ^ _c4.GetHashCode() ^ _c5.GetHashCode() ^ _c6.GetHashCode() ^ _c7.GetHashCode() ^ _c8.GetHashCode();

		/// <summary>
		/// The 9x9-matrix' string representation
		/// </summary>
		/// <returns>String representation</returns>
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,12:F8}"))} |"));


        public static bool operator ==(mat9 m1, mat9 m2) => m1.Equals(m2);

        public static bool operator !=(mat9 m1, mat9 m2) => !(m1 == m2);

        public static mat9 operator +(mat9 m) => m;

        public static mat9 operator -(mat9 m) => m * -1f;

        public static mat9 operator -(float f, mat9 m) => new mat9(f) - m;

        public static mat9 operator -(mat9 m, float f) => m + -f;

        public static mat9 operator +(float f, mat9 m) => m + f;

        public static mat9 operator +(mat9 m, float f) => m + new mat9(f);

        public static mat9 operator -(mat9 m1, mat9 m2) => m1 + -m2;

        public static mat9 operator +(mat9 m1, mat9 m2) => new mat9(m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6], m1[7] + m2[7], m1[8] + m2[8]);

        public static vec9 operator *(mat9 m, vec9 v) =>
			new vec9(Enumerable.Range(0, Dimension).Select(i => Enumerable.Range(0, Dimension).Sum(j => m[i, j] * v[j])));

        public static mat9 operator *(mat9 m1, mat9 m2)
		{
			int[] range = Enumerable.Range(0, Dimension).ToArray();
		
			return new mat9(range.Select(j => new vec9(range.Select(i => range.Sum(k => m1[k, j] * m2[i, k])))));
		}

        public static mat9 operator *(mat9 m, float f) => new mat9(m[0] * f, m[1] * f, m[2] * f, m[3] * f, m[4] * f, m[5] * f, m[6] * f, m[7] * f, m[8] * f);

        public static mat9 operator /(mat9 m, float f) => m * (1 / f);

        public static implicit operator (vec9 x0, vec9 x1, vec9 x2, vec9 x3, vec9 x4, vec9 x5, vec9 x6, vec9 x7, vec9 x8) (mat9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

        public static implicit operator mat9((vec9 x0, vec9 x1, vec9 x2, vec9 x3, vec9 x4, vec9 x5, vec9 x6, vec9 x7, vec9 x8) t) => new mat9(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);

        public static explicit operator ((float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c6, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c7, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c8) (mat9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

        public static explicit operator mat9(((float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c0, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c1, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c2, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c3, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c4, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c5, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c6, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c7, (float r0, float r1, float r2, float r3, float r4, float r5, float r6, float r7, float r8) c8) t) => new mat9(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7, t.c8);

		public static implicit operator (float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x07, float x08, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x17, float x18, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x27, float x28, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x37, float x38, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x47, float x48, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x57, float x58, float x60, float x61, float x62, float x63, float x64, float x65, float x66, float x67, float x68, float x70, float x71, float x72, float x73, float x74, float x75, float x76, float x77, float x78, float x80, float x81, float x82, float x83, float x84, float x85, float x86, float x87, float x88) (mat9 m) => (
            m[0, 0], m[1, 0], m[2, 0], m[3, 0], m[4, 0], m[5, 0], m[6, 0], m[7, 0], m[8, 0],
            m[0, 1], m[1, 1], m[2, 1], m[3, 1], m[4, 1], m[5, 1], m[6, 1], m[7, 1], m[8, 1],
            m[0, 2], m[1, 2], m[2, 2], m[3, 2], m[4, 2], m[5, 2], m[6, 2], m[7, 2], m[8, 2],
            m[0, 3], m[1, 3], m[2, 3], m[3, 3], m[4, 3], m[5, 3], m[6, 3], m[7, 3], m[8, 3],
            m[0, 4], m[1, 4], m[2, 4], m[3, 4], m[4, 4], m[5, 4], m[6, 4], m[7, 4], m[8, 4],
            m[0, 5], m[1, 5], m[2, 5], m[3, 5], m[4, 5], m[5, 5], m[6, 5], m[7, 5], m[8, 5],
            m[0, 6], m[1, 6], m[2, 6], m[3, 6], m[4, 6], m[5, 6], m[6, 6], m[7, 6], m[8, 6],
            m[0, 7], m[1, 7], m[2, 7], m[3, 7], m[4, 7], m[5, 7], m[6, 7], m[7, 7], m[8, 7],
            m[0, 8], m[1, 8], m[2, 8], m[3, 8], m[4, 8], m[5, 8], m[6, 8], m[7, 8], m[8, 8]
		);

		public static implicit operator mat9((float x00, float x01, float x02, float x03, float x04, float x05, float x06, float x07, float x08, float x10, float x11, float x12, float x13, float x14, float x15, float x16, float x17, float x18, float x20, float x21, float x22, float x23, float x24, float x25, float x26, float x27, float x28, float x30, float x31, float x32, float x33, float x34, float x35, float x36, float x37, float x38, float x40, float x41, float x42, float x43, float x44, float x45, float x46, float x47, float x48, float x50, float x51, float x52, float x53, float x54, float x55, float x56, float x57, float x58, float x60, float x61, float x62, float x63, float x64, float x65, float x66, float x67, float x68, float x70, float x71, float x72, float x73, float x74, float x75, float x76, float x77, float x78, float x80, float x81, float x82, float x83, float x84, float x85, float x86, float x87, float x88) t) => (
            (t.x00, t.x10, t.x20, t.x30, t.x40, t.x50, t.x60, t.x70, t.x80),
            (t.x01, t.x11, t.x21, t.x31, t.x41, t.x51, t.x61, t.x71, t.x81),
            (t.x02, t.x12, t.x22, t.x32, t.x42, t.x52, t.x62, t.x72, t.x82),
            (t.x03, t.x13, t.x23, t.x33, t.x43, t.x53, t.x63, t.x73, t.x83),
            (t.x04, t.x14, t.x24, t.x34, t.x44, t.x54, t.x64, t.x74, t.x84),
            (t.x05, t.x15, t.x25, t.x35, t.x45, t.x55, t.x65, t.x75, t.x85),
            (t.x06, t.x16, t.x26, t.x36, t.x46, t.x56, t.x66, t.x76, t.x86),
            (t.x07, t.x17, t.x27, t.x37, t.x47, t.x57, t.x67, t.x77, t.x87),
            (t.x08, t.x18, t.x28, t.x38, t.x48, t.x58, t.x68, t.x78, t.x88)
		);

        public static explicit operator vec9[](mat9 m) => m.Columns;
		
        public static explicit operator float[](mat9 m) => m.ToArray();
		
        public static implicit operator mat9(vec9[] arr) => new mat9(arr);

        public static implicit operator mat9(float[] arr) => new mat9(arr);
    }

	#endregion
}
