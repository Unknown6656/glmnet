// Autogenerated 2018-09-16 13:48:05.572977

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
	#region vec2

	/// <summary>
    /// Represents a 2-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec2
        : ivec<vec2>
    {
		private float _0;
		private float _1;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public float X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public float Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec2.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1);
		
        /// <inheritdoc/>
        public vec2 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 2;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec2 Zero { get; } = new vec2(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec2 UnitX { get; } = (1, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec2 UnitY { get; } = (0, 1);


		/// <summary>
        /// Creates a new 2-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec2(float s)
            : this(s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 2-dimensional vector
        /// </summary>
        public vec2(float x0, float x1)
        {
			_0 = x0;
			_1 = x1;
		}

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 2-dimensional one
        /// </summary>
        /// <param name="v">The 2-dimensional vector</param>
        public vec2(vec2 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 3-dimensional one
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        public vec2(vec3 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec2(vec4 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec2(vec5 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec2(vec6 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec2(vec7 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec2(vec8 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec2(vec9 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec2(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[2]);
			
			
        /// <inheritdoc/>
		public float Dot(vec2 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec2 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec2 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec2 v && v._0.@is(_0) && v._1.@is(_1);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec2 v1, vec2 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec2 v1, vec2 v2) => v1.IsLinearIndependent(v2);


        public static vec2 operator ~(vec2 v) => v.Normalized;

        public static vec2 operator -(vec2 v) => v * -1;

        public static vec2 operator +(vec2 v1, vec2 v2) => (v1._0 + v2._0, v1._1 + v2._1);

        public static vec2 operator +(vec2 v, float f) => v + new vec2(f);

        public static vec2 operator -(vec2 v1, vec2 v2) => v1 + -v2;

        public static vec2 operator -(vec2 v, float f) => v + -f;

        public static vec2 operator *(vec2 v, float f) => v * new vec2(f);

        public static vec2 operator *(float f, vec2 v) => v * f;

        public static vec2 operator -(float f, vec2 v) => -v + f;

        public static vec2 operator *(vec2 v1, vec2 v2) => (v1._0 * v2._0, v1._1 * v2._1);

        public static vec2 operator /(vec2 v, float f) => v * (1 / f);

        public static float operator /(vec2 v1, vec2 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec2 v1, vec2 v2) => v1.Length < v2.Length;

        public static bool operator >(vec2 v1, vec2 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec2 v1, vec2 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec2 v1, vec2 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec2 v1, vec2 v2) => v1.Equals(v2);

        public static bool operator !=(vec2 v1, vec2 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1) (vec2 v) => (v._0, v._1);

        public static implicit operator vec2((float x0, float x1) t) => new vec2(t.x0, t.x1);
    }

	#endregion
	#region vec3

	/// <summary>
    /// Represents a 3-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec3
        : ivec<vec3>
    {
		private float _0;
		private float _1;
		private float _2;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public float X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public float Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public float Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec3.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2);
		
        /// <inheritdoc/>
        public vec3 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 3;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec3 Zero { get; } = new vec3(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec3 UnitX { get; } = (1, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec3 UnitY { get; } = (0, 1, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec3 UnitZ { get; } = (0, 0, 1);


		/// <summary>
        /// Creates a new 3-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec3(float s)
            : this(s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 3-dimensional vector
        /// </summary>
        public vec3(float x0, float x1, float x2)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
		}

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 3-dimensional one
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        public vec3(vec3 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec3(vec4 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec3(vec5 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec3(vec6 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec3(vec7 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec3(vec8 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec3(vec9 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 2-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 2-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec3(vec2 v, float c)
            : this(v[0], v[1], c)
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec3(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[3]);
			
			
        /// <inheritdoc/>
		public float Dot(vec3 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec3 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec3 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec3 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec3 v1, vec3 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec3 v1, vec3 v2) => v1.IsLinearIndependent(v2);


        public static vec3 operator ~(vec3 v) => v.Normalized;

        public static vec3 operator -(vec3 v) => v * -1;

        public static vec3 operator +(vec3 v1, vec3 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2);

        public static vec3 operator +(vec3 v, float f) => v + new vec3(f);

        public static vec3 operator -(vec3 v1, vec3 v2) => v1 + -v2;

        public static vec3 operator -(vec3 v, float f) => v + -f;

        public static vec3 operator *(vec3 v, float f) => v * new vec3(f);

        public static vec3 operator *(float f, vec3 v) => v * f;

        public static vec3 operator -(float f, vec3 v) => -v + f;

        public static vec3 operator *(vec3 v1, vec3 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2);

        public static vec3 operator /(vec3 v, float f) => v * (1 / f);

        public static float operator /(vec3 v1, vec3 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec3 v1, vec3 v2) => v1.Length < v2.Length;

        public static bool operator >(vec3 v1, vec3 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec3 v1, vec3 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec3 v1, vec3 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec3 v1, vec3 v2) => v1.Equals(v2);

        public static bool operator !=(vec3 v1, vec3 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2) (vec3 v) => (v._0, v._1, v._2);

        public static implicit operator vec3((float x0, float x1, float x2) t) => new vec3(t.x0, t.x1, t.x2);
    }

	#endregion
	#region vec4

	/// <summary>
    /// Represents a 4-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec4
        : ivec<vec4>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public float X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public float Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public float Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's W-coefficient
        /// </summary>
        public float W
		{
			get => _3;
			set => _3 = value;
		}

        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec4.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3);
		
        /// <inheritdoc/>
        public vec4 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 4;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec4 Zero { get; } = new vec4(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec4 UnitX { get; } = (1, 0, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec4 UnitY { get; } = (0, 1, 0, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec4 UnitZ { get; } = (0, 0, 1, 0);

        /// <summary>
        /// The unit vector in W-direction
        /// </summary>
        public static vec4 UnitW { get; } = (0, 0, 0, 1);


		/// <summary>
        /// Creates a new 4-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec4(float s)
            : this(s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 4-dimensional vector
        /// </summary>
        public vec4(float x0, float x1, float x2, float x3)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
		}

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec4(vec4 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec4(vec5 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec4(vec6 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec4(vec7 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec4(vec8 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec4(vec9 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 3-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec4(vec3 v, float c)
            : this(v[0], v[1], v[2], c)
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec4(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[4]);
			
			
        /// <inheritdoc/>
		public float Dot(vec4 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec4 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec4 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec4 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec4 v1, vec4 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec4 v1, vec4 v2) => v1.IsLinearIndependent(v2);


        public static vec4 operator ~(vec4 v) => v.Normalized;

        public static vec4 operator -(vec4 v) => v * -1;

        public static vec4 operator +(vec4 v1, vec4 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3);

        public static vec4 operator +(vec4 v, float f) => v + new vec4(f);

        public static vec4 operator -(vec4 v1, vec4 v2) => v1 + -v2;

        public static vec4 operator -(vec4 v, float f) => v + -f;

        public static vec4 operator *(vec4 v, float f) => v * new vec4(f);

        public static vec4 operator *(float f, vec4 v) => v * f;

        public static vec4 operator -(float f, vec4 v) => -v + f;

        public static vec4 operator *(vec4 v1, vec4 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3);

        public static vec4 operator /(vec4 v, float f) => v * (1 / f);

        public static float operator /(vec4 v1, vec4 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec4 v1, vec4 v2) => v1.Length < v2.Length;

        public static bool operator >(vec4 v1, vec4 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec4 v1, vec4 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec4 v1, vec4 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec4 v1, vec4 v2) => v1.Equals(v2);

        public static bool operator !=(vec4 v1, vec4 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3) (vec4 v) => (v._0, v._1, v._2, v._3);

        public static implicit operator vec4((float x0, float x1, float x2, float x3) t) => new vec4(t.x0, t.x1, t.x2, t.x3);
    }

	#endregion
	#region vec5

	/// <summary>
    /// Represents a 5-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec5
        : ivec<vec5>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;
		private float _4;


        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec5.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4);
		
        /// <inheritdoc/>
        public vec5 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 5;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec5 Zero { get; } = new vec5(0);


		/// <summary>
        /// Creates a new 5-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec5(float s)
            : this(s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 5-dimensional vector
        /// </summary>
        public vec5(float x0, float x1, float x2, float x3, float x4)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
		}

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec5(vec5 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec5(vec6 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec5(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec5(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec5(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 4-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec5(vec4 v, float c)
            : this(v[0], v[1], v[2], v[3], c)
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec5(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[5]);
			
			
        /// <inheritdoc/>
		public float Dot(vec5 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec5 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec5 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3, _4 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec5 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec5 v1, vec5 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec5 v1, vec5 v2) => v1.IsLinearIndependent(v2);


        public static vec5 operator ~(vec5 v) => v.Normalized;

        public static vec5 operator -(vec5 v) => v * -1;

        public static vec5 operator +(vec5 v1, vec5 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4);

        public static vec5 operator +(vec5 v, float f) => v + new vec5(f);

        public static vec5 operator -(vec5 v1, vec5 v2) => v1 + -v2;

        public static vec5 operator -(vec5 v, float f) => v + -f;

        public static vec5 operator *(vec5 v, float f) => v * new vec5(f);

        public static vec5 operator *(float f, vec5 v) => v * f;

        public static vec5 operator -(float f, vec5 v) => -v + f;

        public static vec5 operator *(vec5 v1, vec5 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4);

        public static vec5 operator /(vec5 v, float f) => v * (1 / f);

        public static float operator /(vec5 v1, vec5 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec5 v1, vec5 v2) => v1.Length < v2.Length;

        public static bool operator >(vec5 v1, vec5 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec5 v1, vec5 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec5 v1, vec5 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec5 v1, vec5 v2) => v1.Equals(v2);

        public static bool operator !=(vec5 v1, vec5 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3, float x4) (vec5 v) => (v._0, v._1, v._2, v._3, v._4);

        public static implicit operator vec5((float x0, float x1, float x2, float x3, float x4) t) => new vec5(t.x0, t.x1, t.x2, t.x3, t.x4);
    }

	#endregion
	#region vec6

	/// <summary>
    /// Represents a 6-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec6
        : ivec<vec6>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;
		private float _4;
		private float _5;


        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec6.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5);
		
        /// <inheritdoc/>
        public vec6 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 6;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec6 Zero { get; } = new vec6(0);


		/// <summary>
        /// Creates a new 6-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec6(float s)
            : this(s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 6-dimensional vector
        /// </summary>
        public vec6(float x0, float x1, float x2, float x3, float x4, float x5)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
		}

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec6(vec6 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec6(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec6(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec6(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 5-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec6(vec5 v, float c)
            : this(v[0], v[1], v[2], v[3], v[4], c)
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec6(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[6]);
			
			
        /// <inheritdoc/>
		public float Dot(vec6 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec6 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec6 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3, _4, _5 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec6 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec6 v1, vec6 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec6 v1, vec6 v2) => v1.IsLinearIndependent(v2);


        public static vec6 operator ~(vec6 v) => v.Normalized;

        public static vec6 operator -(vec6 v) => v * -1;

        public static vec6 operator +(vec6 v1, vec6 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5);

        public static vec6 operator +(vec6 v, float f) => v + new vec6(f);

        public static vec6 operator -(vec6 v1, vec6 v2) => v1 + -v2;

        public static vec6 operator -(vec6 v, float f) => v + -f;

        public static vec6 operator *(vec6 v, float f) => v * new vec6(f);

        public static vec6 operator *(float f, vec6 v) => v * f;

        public static vec6 operator -(float f, vec6 v) => -v + f;

        public static vec6 operator *(vec6 v1, vec6 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5);

        public static vec6 operator /(vec6 v, float f) => v * (1 / f);

        public static float operator /(vec6 v1, vec6 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec6 v1, vec6 v2) => v1.Length < v2.Length;

        public static bool operator >(vec6 v1, vec6 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec6 v1, vec6 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec6 v1, vec6 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec6 v1, vec6 v2) => v1.Equals(v2);

        public static bool operator !=(vec6 v1, vec6 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3, float x4, float x5) (vec6 v) => (v._0, v._1, v._2, v._3, v._4, v._5);

        public static implicit operator vec6((float x0, float x1, float x2, float x3, float x4, float x5) t) => new vec6(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);
    }

	#endregion
	#region vec7

	/// <summary>
    /// Represents a 7-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec7
        : ivec<vec7>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;
		private float _4;
		private float _5;
		private float _6;


        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec7.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6);
		
        /// <inheritdoc/>
        public vec7 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 7;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec7 Zero { get; } = new vec7(0);


		/// <summary>
        /// Creates a new 7-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec7(float s)
            : this(s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 7-dimensional vector
        /// </summary>
        public vec7(float x0, float x1, float x2, float x3, float x4, float x5, float x6)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
		}

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec7(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec7(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec7(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 6-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec7(vec6 v, float c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], c)
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec7(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[7]);
			
			
        /// <inheritdoc/>
		public float Dot(vec7 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec7 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec7 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec7 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec7 v1, vec7 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec7 v1, vec7 v2) => v1.IsLinearIndependent(v2);


        public static vec7 operator ~(vec7 v) => v.Normalized;

        public static vec7 operator -(vec7 v) => v * -1;

        public static vec7 operator +(vec7 v1, vec7 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6);

        public static vec7 operator +(vec7 v, float f) => v + new vec7(f);

        public static vec7 operator -(vec7 v1, vec7 v2) => v1 + -v2;

        public static vec7 operator -(vec7 v, float f) => v + -f;

        public static vec7 operator *(vec7 v, float f) => v * new vec7(f);

        public static vec7 operator *(float f, vec7 v) => v * f;

        public static vec7 operator -(float f, vec7 v) => -v + f;

        public static vec7 operator *(vec7 v1, vec7 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6);

        public static vec7 operator /(vec7 v, float f) => v * (1 / f);

        public static float operator /(vec7 v1, vec7 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec7 v1, vec7 v2) => v1.Length < v2.Length;

        public static bool operator >(vec7 v1, vec7 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec7 v1, vec7 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec7 v1, vec7 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec7 v1, vec7 v2) => v1.Equals(v2);

        public static bool operator !=(vec7 v1, vec7 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3, float x4, float x5, float x6) (vec7 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6);

        public static implicit operator vec7((float x0, float x1, float x2, float x3, float x4, float x5, float x6) t) => new vec7(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);
    }

	#endregion
	#region vec8

	/// <summary>
    /// Represents a 8-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec8
        : ivec<vec8>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;
		private float _4;
		private float _5;
		private float _6;
		private float _7;


        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
					case 7: return _7;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
				else if (index == 7) _7 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec8.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6 + _7 * _7);
		
        /// <inheritdoc/>
        public vec8 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 8;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec8 Zero { get; } = new vec8(0);


		/// <summary>
        /// Creates a new 8-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec8(float s)
            : this(s, s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 8-dimensional vector
        /// </summary>
        public vec8(float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
			_7 = x7;
		}

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec8(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec8(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 7-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec8(vec7 v, float c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], c)
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec8(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[8]);
			
			
        /// <inheritdoc/>
		public float Dot(vec8 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec8 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec8 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6, _7 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec8 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6) && v._7.@is(_7);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode() ^ _7.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec8 v1, vec8 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec8 v1, vec8 v2) => v1.IsLinearIndependent(v2);


        public static vec8 operator ~(vec8 v) => v.Normalized;

        public static vec8 operator -(vec8 v) => v * -1;

        public static vec8 operator +(vec8 v1, vec8 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6, v1._7 + v2._7);

        public static vec8 operator +(vec8 v, float f) => v + new vec8(f);

        public static vec8 operator -(vec8 v1, vec8 v2) => v1 + -v2;

        public static vec8 operator -(vec8 v, float f) => v + -f;

        public static vec8 operator *(vec8 v, float f) => v * new vec8(f);

        public static vec8 operator *(float f, vec8 v) => v * f;

        public static vec8 operator -(float f, vec8 v) => -v + f;

        public static vec8 operator *(vec8 v1, vec8 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6, v1._7 * v2._7);

        public static vec8 operator /(vec8 v, float f) => v * (1 / f);

        public static float operator /(vec8 v1, vec8 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec8 v1, vec8 v2) => v1.Length < v2.Length;

        public static bool operator >(vec8 v1, vec8 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec8 v1, vec8 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec8 v1, vec8 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec8 v1, vec8 v2) => v1.Equals(v2);

        public static bool operator !=(vec8 v1, vec8 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7) (vec8 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7);

        public static implicit operator vec8((float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7) t) => new vec8(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);
    }

	#endregion
	#region vec9

	/// <summary>
    /// Represents a 9-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec9
        : ivec<vec9>
    {
		private float _0;
		private float _1;
		private float _2;
		private float _3;
		private float _4;
		private float _5;
		private float _6;
		private float _7;
		private float _8;


        /// <inheritdoc/>
        public float this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
					case 7: return _7;
					case 8: return _8;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
				else if (index == 7) _7 = value;
				else if (index == 8) _8 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec9.Dimension;
		
        /// <inheritdoc/>
        public float Length => (float)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6 + _7 * _7 + _8 * _8);
		
        /// <inheritdoc/>
        public vec9 Normalized => this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 9;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec9 Zero { get; } = new vec9(0);


		/// <summary>
        /// Creates a new 9-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec9(float s)
            : this(s, s, s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 9-dimensional vector
        /// </summary>
        public vec9(float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7, float x8)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
			_7 = x7;
			_8 = x8;
		}

		/// <summary>
        /// Creates a new 9-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec9(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
        {
        }

		/// <summary>
        /// Creates a new 9-dimensional vector from the given 8-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec9(vec8 v, float c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], c)
        {
        }

		/// <summary>
        /// Creates a new 9-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec9(IEnumerable<float> v)
            : this() => FromArray(v?.ToArray() ?? new float[9]);
			
			
        /// <inheritdoc/>
		public float Dot(vec9 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec9 other) => !(this / other).is_zero();

        /// <inheritdoc/>
        public int CompareTo(vec9 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7}, {_8})";
		
        /// <inheritdoc/>
        public void FromArray(params float[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public float[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6, _7, _8 };

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec9 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6) && v._7.@is(_7) && v._8.@is(_8);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode() ^ _7.GetHashCode() ^ _8.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static float Dot(vec9 v1, vec9 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec9 v1, vec9 v2) => v1.IsLinearIndependent(v2);


        public static vec9 operator ~(vec9 v) => v.Normalized;

        public static vec9 operator -(vec9 v) => v * -1;

        public static vec9 operator +(vec9 v1, vec9 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6, v1._7 + v2._7, v1._8 + v2._8);

        public static vec9 operator +(vec9 v, float f) => v + new vec9(f);

        public static vec9 operator -(vec9 v1, vec9 v2) => v1 + -v2;

        public static vec9 operator -(vec9 v, float f) => v + -f;

        public static vec9 operator *(vec9 v, float f) => v * new vec9(f);

        public static vec9 operator *(float f, vec9 v) => v * f;

        public static vec9 operator -(float f, vec9 v) => -v + f;

        public static vec9 operator *(vec9 v1, vec9 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6, v1._7 * v2._7, v1._8 * v2._8);

        public static vec9 operator /(vec9 v, float f) => v * (1 / f);

        public static float operator /(vec9 v1, vec9 v2)
        {
            float[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : float.NaN;
        }

        public static bool operator <(vec9 v1, vec9 v2) => v1.Length < v2.Length;

        public static bool operator >(vec9 v1, vec9 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec9 v1, vec9 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec9 v1, vec9 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec9 v1, vec9 v2) => v1.Equals(v2);

        public static bool operator !=(vec9 v1, vec9 v2) => !(v1 == v2);

        public static implicit operator (float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7, float x8) (vec9 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8);

        public static implicit operator vec9((float x0, float x1, float x2, float x3, float x4, float x5, float x6, float x7, float x8) t) => new vec9(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);
    }

	#endregion
}
