// Autogenerated 2018-09-17 20:18:54.564497

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Linq;
using System;


namespace GlmNet
{
#if DOUBLE_PRECISION
    using scalar = Double;
#else
    using scalar = Single;
#endif

	#region vec2

	/// <summary>
    /// Represents a 2-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec2
        : ivec<vec2>
    {
		private scalar _0;
		private scalar _1;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public scalar X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public scalar Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec2.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1);
		
        /// <inheritdoc/>
        public vec2 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 2;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec2 Zero { get; } = new vec2(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec2 UnitX { get; } = (1, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec2 UnitY { get; } = (0, 1);


		/// <summary>
        /// Creates a new 2-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec2(scalar s)
            : this(s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 2-dimensional vector
        /// </summary>
        public vec2(scalar x0, scalar x1)
        {
			_0 = x0;
			_1 = x1;
		}

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 2-dimensional one
        /// </summary>
        /// <param name="v">The 2-dimensional vector</param>
        public vec2(vec2 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 3-dimensional one
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        public vec2(vec3 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec2(vec4 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec2(vec5 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec2(vec6 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec2(vec7 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec2(vec8 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec2(vec9 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec2(vec10 v)
            : this(v[0], v[1])
        {
        }

		/// <summary>
        /// Creates a new 2-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec2(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[2]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec2 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec2 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec2 SwapEntries(int src_idx, int dst_idx)
		{
		    vec2 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec2 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec2 v && v._0.@is(_0) && v._1.@is(_1);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec2 v1, vec2 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec2 v1, vec2 v2) => v1.IsLinearIndependent(v2);


        public static vec2 operator ~(vec2 v) => v.Normalized;

        public static vec2 operator -(vec2 v) => v * -1;

        public static vec2 operator +(vec2 v1, vec2 v2) => (v1._0 + v2._0, v1._1 + v2._1);

        public static vec2 operator +(vec2 v, scalar f) => v + new vec2(f);

        public static vec2 operator -(vec2 v1, vec2 v2) => v1 + -v2;

        public static vec2 operator -(vec2 v, scalar f) => v + -f;

        public static vec2 operator *(vec2 v, scalar f) => v * new vec2(f);

        public static vec2 operator *(scalar f, vec2 v) => v * f;

        public static vec2 operator -(scalar f, vec2 v) => -v + f;

        public static vec2 operator *(vec2 v1, vec2 v2) => (v1._0 * v2._0, v1._1 * v2._1);

        public static vec2 operator /(vec2 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec2 v1, vec2 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec2 v1, vec2 v2) => v1.Length < v2.Length;

        public static bool operator >(vec2 v1, vec2 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec2 v1, vec2 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec2 v1, vec2 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec2 v1, vec2 v2) => v1.Equals(v2);

        public static bool operator !=(vec2 v1, vec2 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1) (vec2 v) => (v._0, v._1);

        public static implicit operator vec2((scalar x0, scalar x1) t) => new vec2(t.x0, t.x1);

		public static implicit operator poly(vec2 v) => v.ToArray();

		public static explicit operator vec2(poly p) => new vec2(p.Coefficients);
    }

	#endregion
	#region vec3

	/// <summary>
    /// Represents a 3-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec3
        : ivec<vec3>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public scalar X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public scalar Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public scalar Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec3.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2);
		
        /// <inheritdoc/>
        public vec3 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 3;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec3 Zero { get; } = new vec3(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec3 UnitX { get; } = (1, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec3 UnitY { get; } = (0, 1, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec3 UnitZ { get; } = (0, 0, 1);


		/// <summary>
        /// Creates a new 3-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec3(scalar s)
            : this(s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 3-dimensional vector
        /// </summary>
        public vec3(scalar x0, scalar x1, scalar x2)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
		}

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 3-dimensional one
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        public vec3(vec3 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec3(vec4 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec3(vec5 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec3(vec6 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec3(vec7 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec3(vec8 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec3(vec9 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec3(vec10 v)
            : this(v[0], v[1], v[2])
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given 2-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 2-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec3(vec2 v, scalar c)
            : this(v[0], v[1], c)
        {
        }

		/// <summary>
        /// Creates a new 3-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec3(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[3]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec3 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec3 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec3 SwapEntries(int src_idx, int dst_idx)
		{
		    vec3 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec3 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec3 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec3 v1, vec3 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec3 v1, vec3 v2) => v1.IsLinearIndependent(v2);


        public static vec3 operator ~(vec3 v) => v.Normalized;

        public static vec3 operator -(vec3 v) => v * -1;

        public static vec3 operator +(vec3 v1, vec3 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2);

        public static vec3 operator +(vec3 v, scalar f) => v + new vec3(f);

        public static vec3 operator -(vec3 v1, vec3 v2) => v1 + -v2;

        public static vec3 operator -(vec3 v, scalar f) => v + -f;

        public static vec3 operator *(vec3 v, scalar f) => v * new vec3(f);

        public static vec3 operator *(scalar f, vec3 v) => v * f;

        public static vec3 operator -(scalar f, vec3 v) => -v + f;

        public static vec3 operator *(vec3 v1, vec3 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2);

        public static vec3 operator /(vec3 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec3 v1, vec3 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec3 v1, vec3 v2) => v1.Length < v2.Length;

        public static bool operator >(vec3 v1, vec3 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec3 v1, vec3 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec3 v1, vec3 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec3 v1, vec3 v2) => v1.Equals(v2);

        public static bool operator !=(vec3 v1, vec3 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2) (vec3 v) => (v._0, v._1, v._2);

        public static implicit operator vec3((scalar x0, scalar x1, scalar x2) t) => new vec3(t.x0, t.x1, t.x2);

		public static implicit operator poly(vec3 v) => v.ToArray();

		public static explicit operator vec3(poly p) => new vec3(p.Coefficients);
    }

	#endregion
	#region vec4

	/// <summary>
    /// Represents a 4-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec4
        : ivec<vec4>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public scalar X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public scalar Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public scalar Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's W-coefficient
        /// </summary>
        public scalar W
		{
			get => _3;
			set => _3 = value;
		}

        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec4.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3);
		
        /// <inheritdoc/>
        public vec4 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 4;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec4 Zero { get; } = new vec4(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec4 UnitX { get; } = (1, 0, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec4 UnitY { get; } = (0, 1, 0, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec4 UnitZ { get; } = (0, 0, 1, 0);

        /// <summary>
        /// The unit vector in W-direction
        /// </summary>
        public static vec4 UnitW { get; } = (0, 0, 0, 1);


		/// <summary>
        /// Creates a new 4-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec4(scalar s)
            : this(s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 4-dimensional vector
        /// </summary>
        public vec4(scalar x0, scalar x1, scalar x2, scalar x3)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
		}

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 4-dimensional one
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        public vec4(vec4 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec4(vec5 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec4(vec6 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec4(vec7 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec4(vec8 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec4(vec9 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec4(vec10 v)
            : this(v[0], v[1], v[2], v[3])
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given 3-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 3-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec4(vec3 v, scalar c)
            : this(v[0], v[1], v[2], c)
        {
        }

		/// <summary>
        /// Creates a new 4-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec4(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[4]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec4 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec4 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec4 SwapEntries(int src_idx, int dst_idx)
		{
		    vec4 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec4 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec4 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec4 v1, vec4 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec4 v1, vec4 v2) => v1.IsLinearIndependent(v2);


        public static vec4 operator ~(vec4 v) => v.Normalized;

        public static vec4 operator -(vec4 v) => v * -1;

        public static vec4 operator +(vec4 v1, vec4 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3);

        public static vec4 operator +(vec4 v, scalar f) => v + new vec4(f);

        public static vec4 operator -(vec4 v1, vec4 v2) => v1 + -v2;

        public static vec4 operator -(vec4 v, scalar f) => v + -f;

        public static vec4 operator *(vec4 v, scalar f) => v * new vec4(f);

        public static vec4 operator *(scalar f, vec4 v) => v * f;

        public static vec4 operator -(scalar f, vec4 v) => -v + f;

        public static vec4 operator *(vec4 v1, vec4 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3);

        public static vec4 operator /(vec4 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec4 v1, vec4 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec4 v1, vec4 v2) => v1.Length < v2.Length;

        public static bool operator >(vec4 v1, vec4 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec4 v1, vec4 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec4 v1, vec4 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec4 v1, vec4 v2) => v1.Equals(v2);

        public static bool operator !=(vec4 v1, vec4 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3) (vec4 v) => (v._0, v._1, v._2, v._3);

        public static implicit operator vec4((scalar x0, scalar x1, scalar x2, scalar x3) t) => new vec4(t.x0, t.x1, t.x2, t.x3);

		public static implicit operator poly(vec4 v) => v.ToArray();

		public static explicit operator vec4(poly p) => new vec4(p.Coefficients);
    }

	#endregion
	#region vec5

	/// <summary>
    /// Represents a 5-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec5
        : ivec<vec5>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public scalar X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public scalar Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public scalar Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's W-coefficient
        /// </summary>
        public scalar W
		{
			get => _3;
			set => _3 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's V-coefficient
        /// </summary>
        public scalar V
		{
			get => _4;
			set => _4 = value;
		}

        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec5.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4);
		
        /// <inheritdoc/>
        public vec5 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 5;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec5 Zero { get; } = new vec5(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec5 UnitX { get; } = (1, 0, 0, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec5 UnitY { get; } = (0, 1, 0, 0, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec5 UnitZ { get; } = (0, 0, 1, 0, 0);

        /// <summary>
        /// The unit vector in W-direction
        /// </summary>
        public static vec5 UnitW { get; } = (0, 0, 0, 1, 0);

        /// <summary>
        /// The unit vector in V-direction
        /// </summary>
        public static vec5 UnitV { get; } = (0, 0, 0, 0, 1);


		/// <summary>
        /// Creates a new 5-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec5(scalar s)
            : this(s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 5-dimensional vector
        /// </summary>
        public vec5(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
		}

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 5-dimensional one
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        public vec5(vec5 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec5(vec6 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec5(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec5(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec5(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec5(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4])
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given 4-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 4-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec5(vec4 v, scalar c)
            : this(v[0], v[1], v[2], v[3], c)
        {
        }

		/// <summary>
        /// Creates a new 5-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec5(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[5]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec5 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec5 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec5 SwapEntries(int src_idx, int dst_idx)
		{
		    vec5 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec5 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec5 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec5 v1, vec5 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec5 v1, vec5 v2) => v1.IsLinearIndependent(v2);


        public static vec5 operator ~(vec5 v) => v.Normalized;

        public static vec5 operator -(vec5 v) => v * -1;

        public static vec5 operator +(vec5 v1, vec5 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4);

        public static vec5 operator +(vec5 v, scalar f) => v + new vec5(f);

        public static vec5 operator -(vec5 v1, vec5 v2) => v1 + -v2;

        public static vec5 operator -(vec5 v, scalar f) => v + -f;

        public static vec5 operator *(vec5 v, scalar f) => v * new vec5(f);

        public static vec5 operator *(scalar f, vec5 v) => v * f;

        public static vec5 operator -(scalar f, vec5 v) => -v + f;

        public static vec5 operator *(vec5 v1, vec5 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4);

        public static vec5 operator /(vec5 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec5 v1, vec5 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec5 v1, vec5 v2) => v1.Length < v2.Length;

        public static bool operator >(vec5 v1, vec5 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec5 v1, vec5 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec5 v1, vec5 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec5 v1, vec5 v2) => v1.Equals(v2);

        public static bool operator !=(vec5 v1, vec5 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4) (vec5 v) => (v._0, v._1, v._2, v._3, v._4);

        public static implicit operator vec5((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4) t) => new vec5(t.x0, t.x1, t.x2, t.x3, t.x4);

		public static implicit operator poly(vec5 v) => v.ToArray();

		public static explicit operator vec5(poly p) => new vec5(p.Coefficients);
    }

	#endregion
	#region vec6

	/// <summary>
    /// Represents a 6-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec6
        : ivec<vec6>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;
		private scalar _5;


        /// <summary>
        /// Sets or gets the the vector's X-coefficient
        /// </summary>
        public scalar X
		{
			get => _0;
			set => _0 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Y-coefficient
        /// </summary>
        public scalar Y
		{
			get => _1;
			set => _1 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's Z-coefficient
        /// </summary>
        public scalar Z
		{
			get => _2;
			set => _2 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's W-coefficient
        /// </summary>
        public scalar W
		{
			get => _3;
			set => _3 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's V-coefficient
        /// </summary>
        public scalar V
		{
			get => _4;
			set => _4 = value;
		}

        /// <summary>
        /// Sets or gets the the vector's U-coefficient
        /// </summary>
        public scalar U
		{
			get => _5;
			set => _5 = value;
		}

        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec6.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5);
		
        /// <inheritdoc/>
        public vec6 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 6;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec6 Zero { get; } = new vec6(0);

        /// <summary>
        /// The unit vector in X-direction
        /// </summary>
        public static vec6 UnitX { get; } = (1, 0, 0, 0, 0, 0);

        /// <summary>
        /// The unit vector in Y-direction
        /// </summary>
        public static vec6 UnitY { get; } = (0, 1, 0, 0, 0, 0);

        /// <summary>
        /// The unit vector in Z-direction
        /// </summary>
        public static vec6 UnitZ { get; } = (0, 0, 1, 0, 0, 0);

        /// <summary>
        /// The unit vector in W-direction
        /// </summary>
        public static vec6 UnitW { get; } = (0, 0, 0, 1, 0, 0);

        /// <summary>
        /// The unit vector in V-direction
        /// </summary>
        public static vec6 UnitV { get; } = (0, 0, 0, 0, 1, 0);

        /// <summary>
        /// The unit vector in U-direction
        /// </summary>
        public static vec6 UnitU { get; } = (0, 0, 0, 0, 0, 1);


		/// <summary>
        /// Creates a new 6-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec6(scalar s)
            : this(s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 6-dimensional vector
        /// </summary>
        public vec6(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
		}

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 6-dimensional one
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        public vec6(vec6 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec6(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec6(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec6(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec6(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5])
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given 5-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 5-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec6(vec5 v, scalar c)
            : this(v[0], v[1], v[2], v[3], v[4], c)
        {
        }

		/// <summary>
        /// Creates a new 6-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec6(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[6]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec6 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec6 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec6 SwapEntries(int src_idx, int dst_idx)
		{
		    vec6 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec6 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4, _5 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec6 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec6 v1, vec6 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec6 v1, vec6 v2) => v1.IsLinearIndependent(v2);


        public static vec6 operator ~(vec6 v) => v.Normalized;

        public static vec6 operator -(vec6 v) => v * -1;

        public static vec6 operator +(vec6 v1, vec6 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5);

        public static vec6 operator +(vec6 v, scalar f) => v + new vec6(f);

        public static vec6 operator -(vec6 v1, vec6 v2) => v1 + -v2;

        public static vec6 operator -(vec6 v, scalar f) => v + -f;

        public static vec6 operator *(vec6 v, scalar f) => v * new vec6(f);

        public static vec6 operator *(scalar f, vec6 v) => v * f;

        public static vec6 operator -(scalar f, vec6 v) => -v + f;

        public static vec6 operator *(vec6 v1, vec6 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5);

        public static vec6 operator /(vec6 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec6 v1, vec6 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec6 v1, vec6 v2) => v1.Length < v2.Length;

        public static bool operator >(vec6 v1, vec6 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec6 v1, vec6 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec6 v1, vec6 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec6 v1, vec6 v2) => v1.Equals(v2);

        public static bool operator !=(vec6 v1, vec6 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5) (vec6 v) => (v._0, v._1, v._2, v._3, v._4, v._5);

        public static implicit operator vec6((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5) t) => new vec6(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);

		public static implicit operator poly(vec6 v) => v.ToArray();

		public static explicit operator vec6(poly p) => new vec6(p.Coefficients);
    }

	#endregion
	#region vec7

	/// <summary>
    /// Represents a 7-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec7
        : ivec<vec7>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;
		private scalar _5;
		private scalar _6;


        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec7.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6);
		
        /// <inheritdoc/>
        public vec7 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 7;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec7 Zero { get; } = new vec7(0);


		/// <summary>
        /// Creates a new 7-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec7(scalar s)
            : this(s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 7-dimensional vector
        /// </summary>
        public vec7(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
		}

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 7-dimensional one
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        public vec7(vec7 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec7(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec7(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec7(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given 6-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 6-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec7(vec6 v, scalar c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], c)
        {
        }

		/// <summary>
        /// Creates a new 7-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec7(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[7]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec7 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec7 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec7 SwapEntries(int src_idx, int dst_idx)
		{
		    vec7 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec7 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec7 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec7 v1, vec7 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec7 v1, vec7 v2) => v1.IsLinearIndependent(v2);


        public static vec7 operator ~(vec7 v) => v.Normalized;

        public static vec7 operator -(vec7 v) => v * -1;

        public static vec7 operator +(vec7 v1, vec7 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6);

        public static vec7 operator +(vec7 v, scalar f) => v + new vec7(f);

        public static vec7 operator -(vec7 v1, vec7 v2) => v1 + -v2;

        public static vec7 operator -(vec7 v, scalar f) => v + -f;

        public static vec7 operator *(vec7 v, scalar f) => v * new vec7(f);

        public static vec7 operator *(scalar f, vec7 v) => v * f;

        public static vec7 operator -(scalar f, vec7 v) => -v + f;

        public static vec7 operator *(vec7 v1, vec7 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6);

        public static vec7 operator /(vec7 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec7 v1, vec7 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec7 v1, vec7 v2) => v1.Length < v2.Length;

        public static bool operator >(vec7 v1, vec7 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec7 v1, vec7 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec7 v1, vec7 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec7 v1, vec7 v2) => v1.Equals(v2);

        public static bool operator !=(vec7 v1, vec7 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6) (vec7 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6);

        public static implicit operator vec7((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6) t) => new vec7(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);

		public static implicit operator poly(vec7 v) => v.ToArray();

		public static explicit operator vec7(poly p) => new vec7(p.Coefficients);
    }

	#endregion
	#region vec8

	/// <summary>
    /// Represents a 8-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec8
        : ivec<vec8>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;
		private scalar _5;
		private scalar _6;
		private scalar _7;


        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
					case 7: return _7;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
				else if (index == 7) _7 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec8.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6 + _7 * _7);
		
        /// <inheritdoc/>
        public vec8 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 8;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec8 Zero { get; } = new vec8(0);


		/// <summary>
        /// Creates a new 8-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec8(scalar s)
            : this(s, s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 8-dimensional vector
        /// </summary>
        public vec8(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
			_7 = x7;
		}

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 8-dimensional one
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        public vec8(vec8 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec8(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec8(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given 7-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 7-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec8(vec7 v, scalar c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], c)
        {
        }

		/// <summary>
        /// Creates a new 8-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec8(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[8]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec8 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec8 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec8 SwapEntries(int src_idx, int dst_idx)
		{
		    vec8 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec8 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6, _7 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec8 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6) && v._7.@is(_7);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode() ^ _7.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec8 v1, vec8 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec8 v1, vec8 v2) => v1.IsLinearIndependent(v2);


        public static vec8 operator ~(vec8 v) => v.Normalized;

        public static vec8 operator -(vec8 v) => v * -1;

        public static vec8 operator +(vec8 v1, vec8 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6, v1._7 + v2._7);

        public static vec8 operator +(vec8 v, scalar f) => v + new vec8(f);

        public static vec8 operator -(vec8 v1, vec8 v2) => v1 + -v2;

        public static vec8 operator -(vec8 v, scalar f) => v + -f;

        public static vec8 operator *(vec8 v, scalar f) => v * new vec8(f);

        public static vec8 operator *(scalar f, vec8 v) => v * f;

        public static vec8 operator -(scalar f, vec8 v) => -v + f;

        public static vec8 operator *(vec8 v1, vec8 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6, v1._7 * v2._7);

        public static vec8 operator /(vec8 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec8 v1, vec8 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec8 v1, vec8 v2) => v1.Length < v2.Length;

        public static bool operator >(vec8 v1, vec8 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec8 v1, vec8 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec8 v1, vec8 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec8 v1, vec8 v2) => v1.Equals(v2);

        public static bool operator !=(vec8 v1, vec8 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7) (vec8 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7);

        public static implicit operator vec8((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7) t) => new vec8(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);

		public static implicit operator poly(vec8 v) => v.ToArray();

		public static explicit operator vec8(poly p) => new vec8(p.Coefficients);
    }

	#endregion
	#region vec9

	/// <summary>
    /// Represents a 9-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec9
        : ivec<vec9>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;
		private scalar _5;
		private scalar _6;
		private scalar _7;
		private scalar _8;


        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
					case 7: return _7;
					case 8: return _8;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
				else if (index == 7) _7 = value;
				else if (index == 8) _8 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec9.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6 + _7 * _7 + _8 * _8);
		
        /// <inheritdoc/>
        public vec9 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 9;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec9 Zero { get; } = new vec9(0);


		/// <summary>
        /// Creates a new 9-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec9(scalar s)
            : this(s, s, s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 9-dimensional vector
        /// </summary>
        public vec9(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
			_7 = x7;
			_8 = x8;
		}

		/// <summary>
        /// Creates a new 9-dimensional vector from the given 9-dimensional one
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        public vec9(vec9 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
        {
        }

		/// <summary>
        /// Creates a new 9-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec9(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
        {
        }

		/// <summary>
        /// Creates a new 9-dimensional vector from the given 8-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 8-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec9(vec8 v, scalar c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], c)
        {
        }

		/// <summary>
        /// Creates a new 9-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec9(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[9]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec9 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec9 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec9 SwapEntries(int src_idx, int dst_idx)
		{
		    vec9 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec9 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7}, {_8})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6, _7, _8 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec9 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6) && v._7.@is(_7) && v._8.@is(_8);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode() ^ _7.GetHashCode() ^ _8.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec9 v1, vec9 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec9 v1, vec9 v2) => v1.IsLinearIndependent(v2);


        public static vec9 operator ~(vec9 v) => v.Normalized;

        public static vec9 operator -(vec9 v) => v * -1;

        public static vec9 operator +(vec9 v1, vec9 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6, v1._7 + v2._7, v1._8 + v2._8);

        public static vec9 operator +(vec9 v, scalar f) => v + new vec9(f);

        public static vec9 operator -(vec9 v1, vec9 v2) => v1 + -v2;

        public static vec9 operator -(vec9 v, scalar f) => v + -f;

        public static vec9 operator *(vec9 v, scalar f) => v * new vec9(f);

        public static vec9 operator *(scalar f, vec9 v) => v * f;

        public static vec9 operator -(scalar f, vec9 v) => -v + f;

        public static vec9 operator *(vec9 v1, vec9 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6, v1._7 * v2._7, v1._8 * v2._8);

        public static vec9 operator /(vec9 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec9 v1, vec9 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec9 v1, vec9 v2) => v1.Length < v2.Length;

        public static bool operator >(vec9 v1, vec9 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec9 v1, vec9 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec9 v1, vec9 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec9 v1, vec9 v2) => v1.Equals(v2);

        public static bool operator !=(vec9 v1, vec9 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8) (vec9 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8);

        public static implicit operator vec9((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8) t) => new vec9(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);

		public static implicit operator poly(vec9 v) => v.ToArray();

		public static explicit operator vec9(poly p) => new vec9(p.Coefficients);
    }

	#endregion
	#region vec10

	/// <summary>
    /// Represents a 10-dimensional vector.
    /// </summary>
    /// <inheritdoc cref="ivec{V}"/>
	[StructLayout(LayoutKind.Sequential), NativeCppClass]
    public struct vec10
        : ivec<vec10>
    {
		private scalar _0;
		private scalar _1;
		private scalar _2;
		private scalar _3;
		private scalar _4;
		private scalar _5;
		private scalar _6;
		private scalar _7;
		private scalar _8;
		private scalar _9;


        /// <inheritdoc/>
        public scalar this[int index]
        {
            get
            {
                switch (index)
                {
					case 0: return _0;
					case 1: return _1;
					case 2: return _2;
					case 3: return _3;
					case 4: return _4;
					case 5: return _5;
					case 6: return _6;
					case 7: return _7;
					case 8: return _8;
					case 9: return _9;
                    default: throw new IndexOutOfRangeException();
                }
            }
            set
            {
				if (index == 0) _0 = value;
				else if (index == 1) _1 = value;
				else if (index == 2) _2 = value;
				else if (index == 3) _3 = value;
				else if (index == 4) _4 = value;
				else if (index == 5) _5 = value;
				else if (index == 6) _6 = value;
				else if (index == 7) _7 = value;
				else if (index == 8) _8 = value;
				else if (index == 9) _9 = value;
                else throw new IndexOutOfRangeException();
            }
        }
		
        /// <inheritdoc/>
        public int Size => vec10.Dimension;
		
        /// <inheritdoc/>
        public scalar Length => (scalar)Math.Sqrt(_0 * _0 + _1 * _1 + _2 * _2 + _3 * _3 + _4 * _4 + _5 * _5 + _6 * _6 + _7 * _7 + _8 * _8 + _9 * _9);
		
        /// <inheritdoc/>
        public vec10 Normalized => this == Zero ? Zero : this / Length;

		
        /// <inheritdoc cref="ivec{V}.Size"/>
        public static int Dimension { get; } = 10;
		
        /// <summary>
        /// The zero vector
        /// </summary>
        public static vec10 Zero { get; } = new vec10(0);


		/// <summary>
        /// Creates a new 10-dimensional uniform vector
        /// </summary>
        /// <param name="s">The coefficients' value</param>
        public vec10(scalar s)
            : this(s, s, s, s, s, s, s, s, s, s)
        {
        }
		
		/// <summary>
        /// Creates a new 10-dimensional vector
        /// </summary>
        public vec10(scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8, scalar x9)
        {
			_0 = x0;
			_1 = x1;
			_2 = x2;
			_3 = x3;
			_4 = x4;
			_5 = x5;
			_6 = x6;
			_7 = x7;
			_8 = x8;
			_9 = x9;
		}

		/// <summary>
        /// Creates a new 10-dimensional vector from the given 10-dimensional one
        /// </summary>
        /// <param name="v">The 10-dimensional vector</param>
        public vec10(vec10 v)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9])
        {
        }

		/// <summary>
        /// Creates a new 10-dimensional vector from the given 9-dimensional one and an additional coefficient
        /// </summary>
        /// <param name="v">The 9-dimensional vector</param>
        /// <param name="c">The additional coefficient</param>
        public vec10(vec9 v, scalar c)
            : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], c)
        {
        }

		/// <summary>
        /// Creates a new 10-dimensional vector from the given coefficient array
        /// </summary>
        /// <param name="v">The vector's coefficients</param>
        public vec10(IEnumerable<scalar> v)
            : this() => FromArray(v?.ToArray() ?? new scalar[10]);
			
			
        /// <inheritdoc/>
		public scalar Dot(vec10 other) => (this * other).ToArray().Sum();
		
        /// <inheritdoc/>
		public bool IsLinearIndependent(vec10 other) => !(this / other).is_zero();
		
        /// <inheritdoc/>
		public vec10 SwapEntries(int src_idx, int dst_idx)
		{
		    vec10 res = this;
			scalar tmp = res[dst_idx];
			
			res[dst_idx] = res[src_idx];
			res[src_idx] = tmp;

			return res;
		}

        /// <inheritdoc/>
        public int CompareTo(vec10 other) => Length.CompareTo(other.Length);

        /// <inheritdoc/>
        public override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7}, {_8}, {_9})";
		
        /// <inheritdoc/>
        public void FromArray(params scalar[] v)
        {
            for (int i = 0; i < Dimension; ++i)
                this[i] = i < v.Length ? v[i] : 0;
        }
		
        /// <inheritdoc/>
        public scalar[] ToArray() => new[] { _0, _1, _2, _3, _4, _5, _6, _7, _8, _9 };

        /// <inheritdoc/>
        public poly ToPolynomial() => this;

        /// <inheritdoc/>
        public override bool Equals(object obj) => obj is vec10 v && v._0.@is(_0) && v._1.@is(_1) && v._2.@is(_2) && v._3.@is(_3) && v._4.@is(_4) && v._5.@is(_5) && v._6.@is(_6) && v._7.@is(_7) && v._8.@is(_8) && v._9.@is(_9);

        /// <inheritdoc/>
        public override int GetHashCode() => _0.GetHashCode() ^ _1.GetHashCode() ^ _2.GetHashCode() ^ _3.GetHashCode() ^ _4.GetHashCode() ^ _5.GetHashCode() ^ _6.GetHashCode() ^ _7.GetHashCode() ^ _8.GetHashCode() ^ _9.GetHashCode();

		
        /// <inheritdoc cref="ivec{V}.Dot"/>
		public static scalar Dot(vec10 v1, vec10 v2) => v1.Dot(v2);
		
        /// <inheritdoc cref="ivec{V}.IsLinearIndependent"/>
		public static bool IsLinearIndependent(vec10 v1, vec10 v2) => v1.IsLinearIndependent(v2);


        public static vec10 operator ~(vec10 v) => v.Normalized;

        public static vec10 operator -(vec10 v) => v * -1;

        public static vec10 operator +(vec10 v1, vec10 v2) => (v1._0 + v2._0, v1._1 + v2._1, v1._2 + v2._2, v1._3 + v2._3, v1._4 + v2._4, v1._5 + v2._5, v1._6 + v2._6, v1._7 + v2._7, v1._8 + v2._8, v1._9 + v2._9);

        public static vec10 operator +(vec10 v, scalar f) => v + new vec10(f);

        public static vec10 operator -(vec10 v1, vec10 v2) => v1 + -v2;

        public static vec10 operator -(vec10 v, scalar f) => v + -f;

        public static vec10 operator *(vec10 v, scalar f) => v * new vec10(f);

        public static vec10 operator *(scalar f, vec10 v) => v * f;

        public static vec10 operator -(scalar f, vec10 v) => -v + f;

        public static vec10 operator *(vec10 v1, vec10 v2) => (v1._0 * v2._0, v1._1 * v2._1, v1._2 * v2._2, v1._3 * v2._3, v1._4 * v2._4, v1._5 * v2._5, v1._6 * v2._6, v1._7 * v2._7, v1._8 * v2._8, v1._9 * v2._9);

        public static vec10 operator /(vec10 v, scalar f) => v * (1 / f);

        public static scalar operator /(vec10 v1, vec10 v2)
        {
            scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

            return components.Length == 1 ? components[0] : scalar.NaN;
        }

        public static bool operator <(vec10 v1, vec10 v2) => v1.Length < v2.Length;

        public static bool operator >(vec10 v1, vec10 v2) => v1.Length > v2.Length;

        public static bool operator <=(vec10 v1, vec10 v2) => v1.Length <= v2.Length;

        public static bool operator >=(vec10 v1, vec10 v2) => v1.Length >= v2.Length;

        public static bool operator ==(vec10 v1, vec10 v2) => v1.Equals(v2);

        public static bool operator !=(vec10 v1, vec10 v2) => !(v1 == v2);

        public static implicit operator (scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8, scalar x9) (vec10 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8, v._9);

        public static implicit operator vec10((scalar x0, scalar x1, scalar x2, scalar x3, scalar x4, scalar x5, scalar x6, scalar x7, scalar x8, scalar x9) t) => new vec10(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8, t.x9);

		public static implicit operator poly(vec10 v) => v.ToArray();

		public static explicit operator vec10(poly p) => new vec10(p.Coefficients);
    }

	#endregion
}
